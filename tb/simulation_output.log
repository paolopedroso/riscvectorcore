Building simulation with Verilator...
verilator --cc --exe --build -j 0 -Wall -Wno-fatal --trace   --trace-max-array 1024   --trace-max-width 256    -I../core   -DSIMULATION   --trace-depth 99   --assert   --timing ./sim_main.cpp ../core/top.sv ../core/program_counter.sv ../core/salu.sv ../core/sdatamem.sv ../core/sdecode.sv ../core/sregfile.sv ../core/swbmux.sv ../core/instr_mem.sv ../core/shazard_detection.sv ../core/forwarding_unit.sv --top-module top
make[1]: Entering directory '/mnt/c/Users/paolo/OneDrive/Documents/GitHub/riscvectorcore/tb/obj_dir'
g++  -I.  -MMD -I/usr/share/verilator/include -I/usr/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TRACE=1 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=1 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-overloaded-virtual -Wno-shadow -Wno-sign-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable       -fcoroutines -Os -c -o sim_main.o ../sim_main.cpp
g++ -Os  -I.  -MMD -I/usr/share/verilator/include -I/usr/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TRACE=1 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=1 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-overloaded-virtual -Wno-shadow -Wno-sign-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable       -fcoroutines -c -o verilated.o /usr/share/verilator/include/verilated.cpp
g++ -Os  -I.  -MMD -I/usr/share/verilator/include -I/usr/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TRACE=1 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=1 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-overloaded-virtual -Wno-shadow -Wno-sign-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable       -fcoroutines -c -o verilated_vcd_c.o /usr/share/verilator/include/verilated_vcd_c.cpp
g++ -Os  -I.  -MMD -I/usr/share/verilator/include -I/usr/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TRACE=1 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=1 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-overloaded-virtual -Wno-shadow -Wno-sign-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable       -fcoroutines -c -o verilated_timing.o /usr/share/verilator/include/verilated_timing.cpp
g++ -Os  -I.  -MMD -I/usr/share/verilator/include -I/usr/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TRACE=1 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=1 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-overloaded-virtual -Wno-shadow -Wno-sign-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable       -fcoroutines -c -o verilated_threads.o /usr/share/verilator/include/verilated_threads.cpp
g++ -Os  -I.  -MMD -I/usr/share/verilator/include -I/usr/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TRACE=1 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=1 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-overloaded-virtual -Wno-shadow -Wno-sign-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable       -fcoroutines -x c++-header Vtop__pch.h -o Vtop__pch.h.fast.gch
g++   -I.  -MMD -I/usr/share/verilator/include -I/usr/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TRACE=1 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=1 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-overloaded-virtual -Wno-shadow -Wno-sign-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable       -fcoroutines -x c++-header Vtop__pch.h -o Vtop__pch.h.slow.gch
echo "" > Vtop__ALL.verilator_deplist.tmp
g++ -Os  -I.  -MMD -I/usr/share/verilator/include -I/usr/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TRACE=1 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=1 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-overloaded-virtual -Wno-shadow -Wno-sign-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable       -fcoroutines -include Vtop__pch.h.fast -c -o Vtop.o Vtop.cpp
g++ -Os  -I.  -MMD -I/usr/share/verilator/include -I/usr/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TRACE=1 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=1 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-overloaded-virtual -Wno-shadow -Wno-sign-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable       -fcoroutines -include Vtop__pch.h.fast -c -o Vtop___024root__DepSet_h84412442__0.o Vtop___024root__DepSet_h84412442__0.cpp
g++ -Os  -I.  -MMD -I/usr/share/verilator/include -I/usr/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TRACE=1 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=1 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-overloaded-virtual -Wno-shadow -Wno-sign-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable       -fcoroutines -include Vtop__pch.h.fast -c -o Vtop___024root__DepSet_heccd7ead__0.o Vtop___024root__DepSet_heccd7ead__0.cpp
g++ -Os  -I.  -MMD -I/usr/share/verilator/include -I/usr/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TRACE=1 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=1 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-overloaded-virtual -Wno-shadow -Wno-sign-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable       -fcoroutines -include Vtop__pch.h.fast -c -o Vtop___024root__DepSet_heccd7ead__1.o Vtop___024root__DepSet_heccd7ead__1.cpp
g++ -Os  -I.  -MMD -I/usr/share/verilator/include -I/usr/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TRACE=1 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=1 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-overloaded-virtual -Wno-shadow -Wno-sign-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable       -fcoroutines -include Vtop__pch.h.fast -c -o Vtop__Trace__0.o Vtop__Trace__0.cpp
g++   -I.  -MMD -I/usr/share/verilator/include -I/usr/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TRACE=1 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=1 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-overloaded-virtual -Wno-shadow -Wno-sign-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable       -fcoroutines -include Vtop__pch.h.slow -c -o Vtop__ConstPool_0.o Vtop__ConstPool_0.cpp
g++   -I.  -MMD -I/usr/share/verilator/include -I/usr/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TRACE=1 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=1 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-overloaded-virtual -Wno-shadow -Wno-sign-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable       -fcoroutines -include Vtop__pch.h.slow -c -o Vtop___024root__Slow.o Vtop___024root__Slow.cpp
g++   -I.  -MMD -I/usr/share/verilator/include -I/usr/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TRACE=1 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=1 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-overloaded-virtual -Wno-shadow -Wno-sign-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable       -fcoroutines -include Vtop__pch.h.slow -c -o Vtop___024root__DepSet_h84412442__0__Slow.o Vtop___024root__DepSet_h84412442__0__Slow.cpp
g++   -I.  -MMD -I/usr/share/verilator/include -I/usr/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TRACE=1 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=1 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-overloaded-virtual -Wno-shadow -Wno-sign-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable       -fcoroutines -include Vtop__pch.h.slow -c -o Vtop___024root__DepSet_heccd7ead__0__Slow.o Vtop___024root__DepSet_heccd7ead__0__Slow.cpp
g++   -I.  -MMD -I/usr/share/verilator/include -I/usr/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TRACE=1 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=1 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-overloaded-virtual -Wno-shadow -Wno-sign-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable       -fcoroutines -include Vtop__pch.h.slow -c -o Vtop__Syms.o Vtop__Syms.cpp
g++   -I.  -MMD -I/usr/share/verilator/include -I/usr/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TRACE=1 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=1 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-overloaded-virtual -Wno-shadow -Wno-sign-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable       -fcoroutines -include Vtop__pch.h.slow -c -o Vtop__Trace__0__Slow.o Vtop__Trace__0__Slow.cpp
g++   -I.  -MMD -I/usr/share/verilator/include -I/usr/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TRACE=1 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=1 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-overloaded-virtual -Wno-shadow -Wno-sign-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable       -fcoroutines -include Vtop__pch.h.slow -c -o Vtop__TraceDecls__0__Slow.o Vtop__TraceDecls__0__Slow.cpp
Archive ar -rcs Vtop__ALL.a Vtop.o Vtop___024root__DepSet_h84412442__0.o Vtop___024root__DepSet_heccd7ead__0.o Vtop___024root__DepSet_heccd7ead__1.o Vtop__Trace__0.o Vtop__ConstPool_0.o Vtop___024root__Slow.o Vtop___024root__DepSet_h84412442__0__Slow.o Vtop___024root__DepSet_heccd7ead__0__Slow.o Vtop__Syms.o Vtop__Trace__0__Slow.o Vtop__TraceDecls__0__Slow.o
g++     sim_main.o verilated.o verilated_vcd_c.o verilated_timing.o verilated_threads.o Vtop__ALL.a    -pthread -lpthread -latomic   -o Vtop
rm Vtop__ALL.verilator_deplist.tmp
make[1]: Leaving directory '/mnt/c/Users/paolo/OneDrive/Documents/GitHub/riscvectorcore/tb/obj_dir'
Running simulation...
obj_dir/Vtop
Starting simulation of RISC-V processor...
Verilator version: Verilator 5.020 2024-01-01
Asserting reset...
IMEM: Reading from address 0x00000000, mem_index=0, instruction=0x00100093
WBMUX: Selected ALU result: 0x00000000
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000000 = 0x00000000 (decimal: 0 + 0 = 0)
ALU ADD RESULT BYTES: 00 00 00 00
ALU OUTPUT: alu_res_d = 0x00000000 (bytes: 00 00 00 00)
ALU FLAGS: zero=1, negative=0, overflow=0
ALU OUTPUT: alu_res_d = 0x00000000 (bytes=00 00 00 00)
ALU FLAGS: zero=1, negative=0, overflow=0
DECODE: Instruction: 0x00000000
DECODE: Opcode: 0x00, funct3: 0x0, funct7: 0x00
DECODE: rs1: x0, rs2: x0, rd: x0
WBMUX: Selected ALU result: 0x00000000
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000000 = 0x00000000 (decimal: 0 + 0 = 0)
ALU ADD RESULT BYTES: 00 00 00 00
ALU OUTPUT: alu_res_d = 0x00000000 (bytes: 00 00 00 00)
ALU FLAGS: zero=1, negative=0, overflow=0
IMEM: Reading from address 0x00000000, mem_index=0, instruction=0x00100093
DECODE: Instruction: 0x00000000
DECODE: Opcode: 0x00, funct3: 0x0, funct7: 0x00
DECODE: rs1: x0, rs2: x0, rd: x0
WBMUX: Selected ALU result: 0x00000000
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000000 = 0x00000000 (decimal: 0 + 0 = 0)
ALU ADD RESULT BYTES: 00 00 00 00
ALU OUTPUT: alu_res_d = 0x00000000 (bytes: 00 00 00 00)
ALU FLAGS: zero=1, negative=0, overflow=0
IMEM: Reading from address 0x00000000, mem_index=0, instruction=0x00100093
DECODE: Instruction: 0x00000000
DECODE: Opcode: 0x00, funct3: 0x0, funct7: 0x00
DECODE: rs1: x0, rs2: x0, rd: x0
WBMUX: Selected ALU result: 0x00000000
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000000 = 0x00000000 (decimal: 0 + 0 = 0)
ALU ADD RESULT BYTES: 00 00 00 00
ALU OUTPUT: alu_res_d = 0x00000000 (bytes: 00 00 00 00)
ALU FLAGS: zero=1, negative=0, overflow=0
IMEM: Reading from address 0x00000000, mem_index=0, instruction=0x00100093
DECODE: Instruction: 0x00000000
DECODE: Opcode: 0x00, funct3: 0x0, funct7: 0x00
DECODE: rs1: x0, rs2: x0, rd: x0
WBMUX: Selected ALU result: 0x00000000
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000000 = 0x00000000 (decimal: 0 + 0 = 0)
ALU ADD RESULT BYTES: 00 00 00 00
ALU OUTPUT: alu_res_d = 0x00000000 (bytes: 00 00 00 00)
ALU FLAGS: zero=1, negative=0, overflow=0
IMEM: Reading from address 0x00000000, mem_index=0, instruction=0x00100093
Reset released at time 10
Initial PC value: 0x00000000
Instruction memory contents:
  imem[0] = 0x00100093
    Bytes (little-endian): 93 00 10 00
  imem[1] = 0x00200113
    Bytes (little-endian): 13 01 20 00
  imem[2] = 0x00400193  <- ADD x3, x1, x2
    Bytes (little-endian): 93 01 40 00
  imem[3] = 0x00800213
    Bytes (little-endian): 13 02 80 00
  imem[4] = 0x002081b3
    Bytes (little-endian): b3 81 20 00
  imem[5] = 0x40308233
    Bytes (little-endian): 33 82 30 40
  imem[6] = 0x0020f2b3
    Bytes (little-endian): b3 f2 20 00
  imem[7] = 0x0020e333
    Bytes (little-endian): 33 e3 20 00
  imem[8] = 0x0020c3b3
    Bytes (little-endian): b3 c3 20 00
  imem[9] = 0x00109413
    Bytes (little-endian): 13 94 10 00
  imem[a] = 0x0020d493
    Bytes (little-endian): 93 d4 20 00
  imem[b] = 0x4020d513
    Bytes (little-endian): 13 d5 20 40
  imem[c] = 0x00302023
    Bytes (little-endian): 23 20 30 00
  imem[d] = 0x00402223
    Bytes (little-endian): 23 22 40 00
DECODE: Instruction: 0x00000000
DECODE: Opcode: 0x00, funct3: 0x0, funct7: 0x00
DECODE: rs1: x0, rs2: x0, rd: x0
TOP: IF/ID: Loading instruction 0x00100093 from PC 0x00000000
TOP: ID/EX: Processing instruction 0x00000000
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x0 (0x00000000), rd=x0
WBMUX: Selected ALU result: 0x00000000
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000000 = 0x00000000 (decimal: 0 + 0 = 0)
ALU ADD RESULT BYTES: 00 00 00 00
ALU OUTPUT: alu_res_d = 0x00000000 (bytes: 00 00 00 00)
ALU FLAGS: zero=1, negative=0, overflow=0
IMEM: Reading from address 0x00000004, mem_index=1, instruction=0x00200113
TOP: Executed instruction 0: 0x00100093 at PC=0x00000000
DECODE: Instruction: 0x00100093
DECODE: Opcode: 0x13, funct3: 0x0, funct7: 0x00
DECODE: rs1: x0, rs2: x1, rd: x1
TOP: IF/ID: Loading instruction 0x00200113 from PC 0x00000004
TOP: ID/EX: Processing instruction 0x00100093
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x1 (0x00000000), rd=x1
TOP: ID/EX: imm=0x00000001
WBMUX: Selected ALU result: 0x00000000
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000001 (bytes: 01 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000001 = 0x00000001 (decimal: 0 + 1 = 1)
ALU ADD RESULT BYTES: 01 00 00 00
ALU OUTPUT: alu_res_d = 0x00000001 (bytes: 01 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x00000008, mem_index=2, instruction=0x00400193
ALU OUTPUT: alu_res_d = 0x00000001 (bytes=01 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
TOP: Executed instruction 1: 0x00200113 at PC=0x00000004
DECODE: Instruction: 0x00200113
DECODE: Opcode: 0x13, funct3: 0x0, funct7: 0x00
DECODE: rs1: x0, rs2: x2, rd: x2
TOP: IF/ID: Loading instruction 0x00400193 from PC 0x00000008
TOP: ID/EX: Processing instruction 0x00200113
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x2 (0x00000000), rd=x2
TOP: ID/EX: imm=0x00000002
TOP: EX/MEM: ALU result=0x00000001 for rd=x1
WBMUX: Selected ALU result: 0x00000000
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000002 (bytes: 02 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000002 = 0x00000002 (decimal: 0 + 2 = 2)
ALU ADD RESULT BYTES: 02 00 00 00
ALU OUTPUT: alu_res_d = 0x00000002 (bytes: 02 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x0000000c, mem_index=3, instruction=0x00800213
ALU OUTPUT: alu_res_d = 0x00000002 (bytes=02 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
TOP: Executed instruction 2: 0x00400193 at PC=0x00000008
DECODE: Instruction: 0x00400193
DECODE: Opcode: 0x13, funct3: 0x0, funct7: 0x00
DECODE: rs1: x0, rs2: x4, rd: x3
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x00000001, rd=x1
TOP: IF/ID: Loading instruction 0x00800213 from PC 0x0000000c
TOP: ID/EX: Processing instruction 0x00400193
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x4 (0x00000000), rd=x3
TOP: ID/EX: imm=0x00000004
TOP: EX/MEM: ALU result=0x00000002 for rd=x2
TOP: MEM/WB: Writing back 0x00000001 to rd=x1
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x1, result_src=00
WBMUX: Selected ALU result: 0x00000001
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000004 (bytes: 04 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000004 = 0x00000004 (decimal: 0 + 4 = 4)
ALU ADD RESULT BYTES: 04 00 00 00
ALU OUTPUT: alu_res_d = 0x00000004 (bytes: 04 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x00000010, mem_index=4, instruction=0x002081b3
ALU OUTPUT: alu_res_d = 0x00000004 (bytes=04 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
TOP: About to write to register x1, value=0x00000001, reg_write_en=1
TOP: TOP: About to write to register x1, value=0x00000001, reg_write_en=1
TOP: Executed instruction 3: 0x00800213 at PC=0x0000000c
DECODE: Instruction: 0x00800213
DECODE: Opcode: 0x13, funct3: 0x0, funct7: 0x00
DECODE: rs1: x0, rs2: x8, rd: x4
REGFILE: Writing 0x00000001 to x1
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x00000002, rd=x2
TOP: IF/ID: Loading instruction 0x002081b3 from PC 0x00000010
TOP: ID/EX: Processing instruction 0x00800213
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x8 (0x00000000), rd=x4
TOP: ID/EX: imm=0x00000008
TOP: EX/MEM: ALU result=0x00000004 for rd=x3
TOP: MEM/WB: Writing back 0x00000002 to rd=x2
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x2, result_src=00
WBMUX: Selected ALU result: 0x00000002
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000008 (bytes: 08 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000008 = 0x00000008 (decimal: 0 + 8 = 8)
ALU ADD RESULT BYTES: 08 00 00 00
ALU OUTPUT: alu_res_d = 0x00000008 (bytes: 08 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x00000014, mem_index=5, instruction=0x40308233
ALU OUTPUT: alu_res_d = 0x00000008 (bytes=08 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
TOP: About to write to register x2, value=0x00000002, reg_write_en=1
TOP: TOP: About to write to register x2, value=0x00000002, reg_write_en=1
PIPELINE DEBUG: ADD instruction in ID stage
  x1 value = 0x00000001, x2 value = 0x00000002
TOP: Executed instruction 4: 0x002081b3 at PC=0x00000010
DECODE: Instruction: 0x002081b3
DECODE: Opcode: 0x33, funct3: 0x0, funct7: 0x00
DECODE: rs1: x1, rs2: x2, rd: x3
REGFILE: Writing 0x00000002 to x2
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x00000004, rd=x3
TOP: IF/ID: Loading instruction 0x40308233 from PC 0x00000014
TOP: ID/EX: Processing instruction 0x002081b3
TOP: ID/EX: rs1=x1 (0x00000001), rs2=x2 (0x00000002), rd=x3
TOP: ID/EX PIPELINE: ADD instruction entering EX stage
TOP:   rs1_addr=x1, rs2_addr=x2, rd_addr=x3
TOP:   rs1_data=0x00000001, rs2_data=0x00000002
TOP: EX/MEM: ALU result=0x00000008 for rd=x4
TOP: MEM/WB: Writing back 0x00000004 to rd=x3
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x3, result_src=00
WBMUX: Selected ALU result: 0x00000004
ALU INPUT: rs1_data_i = 0x00000001 (bytes: 01 00 00 00)
ALU INPUT: rs2_data_i = 0x00000002 (bytes: 02 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000001 + 0x00000002 = 0x00000003 (decimal: 1 + 2 = 3)
ALU ADD RESULT BYTES: 03 00 00 00
ALU OUTPUT: alu_res_d = 0x00000003 (bytes: 03 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x00000018, mem_index=6, instruction=0x0020f2b3
ALU OUTPUT: alu_res_d = 0x00000003 (bytes=03 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
TOP: About to write to register x3, value=0x00000004, reg_write_en=1
TOP: TOP: About to write to register x3, value=0x00000004, reg_write_en=1
PIPELINE DEBUG: ADD instruction in EX stage
  alu_input_a = 0x00000001, alu_input_b = 0x00000002
  forward_a = 00, forward_b = 00
  mem_rd_addr = x4, mem_reg_write = 1
  wb_rd_addr = x3, wb_reg_write = 1
TOP: Executed instruction 5: 0x40308233 at PC=0x00000014
DECODE: Instruction: 0x40308233
DECODE: Opcode: 0x33, funct3: 0x0, funct7: 0x20
DECODE: rs1: x1, rs2: x3, rd: x4
REGFILE: Writing 0x00000004 to x3
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x00000008, rd=x4
TOP: IF/ID: Loading instruction 0x0020f2b3 from PC 0x00000018
TOP: ID/EX: Processing instruction 0x40308233
TOP: ID/EX: rs1=x1 (0x00000001), rs2=x3 (0x00000004), rd=x4
TOP: EX/MEM: ALU result=0x00000003 for rd=x3
TOP: MEM/WB: Writing back 0x00000008 to rd=x4
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x4, result_src=00
WBMUX: Selected ALU result: 0x00000008
FWD: Forwarding rs2 from MEM stage: x3
TOP: Using forwarded RS2: forward_b=10, value=0x00000003
ALU INPUT: rs1_data_i = 0x00000001 (bytes: 01 00 00 00)
ALU INPUT: rs2_data_i = 0x00000003 (bytes: 03 00 00 00)
ALU INPUT: alu_op_in = 0001
ALU SUB: 0x00000001 - 0x00000003 = 0xfffffffe (decimal: 1 - 3 = -2)
ALU OUTPUT: alu_res_d = 0xfffffffe (bytes: fe ff ff ff)
ALU FLAGS: zero=0, negative=1, overflow=0
IMEM: Reading from address 0x0000001c, mem_index=7, instruction=0x0020e333
ALU OUTPUT: alu_res_d = 0xfffffffe (bytes=fe ff ff ff)
ALU FLAGS: zero=0, negative=1, overflow=0
TOP: About to write to register x4, value=0x00000008, reg_write_en=1
TOP: TOP: About to write to register x4, value=0x00000008, reg_write_en=1
TOP: Executed instruction 6: 0x0020f2b3 at PC=0x00000018
DECODE: Instruction: 0x0020f2b3
DECODE: Opcode: 0x33, funct3: 0x7, funct7: 0x00
DECODE: rs1: x1, rs2: x2, rd: x5
REGFILE: Writing 0x00000008 to x4
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x00000003, rd=x3
TOP: IF/ID: Loading instruction 0x0020e333 from PC 0x0000001c
TOP: ID/EX: Processing instruction 0x0020f2b3
TOP: ID/EX: rs1=x1 (0x00000001), rs2=x2 (0x00000002), rd=x5
TOP: EX/MEM: ALU result=0xfffffffe for rd=x4
TOP: MEM/WB: Writing back 0x00000003 to rd=x3
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x3, result_src=00
WBMUX: Selected ALU result: 0x00000003
ALU INPUT: rs1_data_i = 0x00000001 (bytes: 01 00 00 00)
ALU INPUT: rs2_data_i = 0x00000002 (bytes: 02 00 00 00)
ALU INPUT: alu_op_in = 1001
ALU AND: 0x00000001 & 0x00000002 = 0x00000000
ALU OUTPUT: alu_res_d = 0x00000000 (bytes: 00 00 00 00)
ALU FLAGS: zero=1, negative=0, overflow=0
IMEM: Reading from address 0x00000020, mem_index=8, instruction=0x0020c3b3
ALU OUTPUT: alu_res_d = 0x00000000 (bytes=00 00 00 00)
ALU FLAGS: zero=1, negative=0, overflow=0
TOP: About to write to register x3, value=0x00000003, reg_write_en=1
TOP: TOP: About to write to register x3, value=0x00000003, reg_write_en=1
TOP: Executed instruction 7: 0x0020e333 at PC=0x0000001c
DECODE: Instruction: 0x0020e333
DECODE: Opcode: 0x33, funct3: 0x6, funct7: 0x00
DECODE: rs1: x1, rs2: x2, rd: x6
REGFILE: Writing 0x00000003 to x3
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0xfffffffe, rd=x4
TOP: IF/ID: Loading instruction 0x0020c3b3 from PC 0x00000020
TOP: ID/EX: Processing instruction 0x0020e333
TOP: ID/EX: rs1=x1 (0x00000001), rs2=x2 (0x00000002), rd=x6
TOP: EX/MEM: ALU result=0x00000000 for rd=x5
TOP: MEM/WB: Writing back 0xfffffffe to rd=x4
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x4, result_src=00
WBMUX: Selected ALU result: 0xfffffffe
ALU INPUT: rs1_data_i = 0x00000001 (bytes: 01 00 00 00)
ALU INPUT: rs2_data_i = 0x00000002 (bytes: 02 00 00 00)
ALU INPUT: alu_op_in = 1000
ALU OR: 0x00000001 | 0x00000002 = 0x00000003
ALU OUTPUT: alu_res_d = 0x00000003 (bytes: 03 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x00000024, mem_index=9, instruction=0x00109413
ALU OUTPUT: alu_res_d = 0x00000003 (bytes=03 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
TOP: About to write to register x4, value=0xfffffffe, reg_write_en=1
TOP: TOP: About to write to register x4, value=0xfffffffe, reg_write_en=1
TOP: Executed instruction 8: 0x0020c3b3 at PC=0x00000020
DECODE: Instruction: 0x0020c3b3
DECODE: Opcode: 0x33, funct3: 0x4, funct7: 0x00
DECODE: rs1: x1, rs2: x2, rd: x7
REGFILE: Writing 0xfffffffe to x4
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x00000000, rd=x5
TOP: IF/ID: Loading instruction 0x00109413 from PC 0x00000024
TOP: ID/EX: Processing instruction 0x0020c3b3
TOP: ID/EX: rs1=x1 (0x00000001), rs2=x2 (0x00000002), rd=x7
TOP: EX/MEM: ALU result=0x00000003 for rd=x6
TOP: MEM/WB: Writing back 0x00000000 to rd=x5
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x5, result_src=00
WBMUX: Selected ALU result: 0x00000000
ALU INPUT: rs1_data_i = 0x00000001 (bytes: 01 00 00 00)
ALU INPUT: rs2_data_i = 0x00000002 (bytes: 02 00 00 00)
ALU INPUT: alu_op_in = 0101
ALU XOR: 0x00000001 ^ 0x00000002 = 0x00000003
ALU OUTPUT: alu_res_d = 0x00000003 (bytes: 03 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x00000028, mem_index=10, instruction=0x0020d493
TOP: About to write to register x5, value=0x00000000, reg_write_en=1
TOP: TOP: About to write to register x5, value=0x00000000, reg_write_en=1
TOP: Executed instruction 9: 0x00109413 at PC=0x00000024
DECODE: Instruction: 0x00109413
DECODE: Opcode: 0x13, funct3: 0x1, funct7: 0x00
DECODE: rs1: x1, rs2: x1, rd: x8
REGFILE: Writing 0x00000000 to x5
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x00000003, rd=x6
TOP: IF/ID: Loading instruction 0x0020d493 from PC 0x00000028
TOP: ID/EX: Processing instruction 0x00109413
TOP: ID/EX: rs1=x1 (0x00000001), rs2=x1 (0x00000001), rd=x8
TOP: ID/EX: imm=0x00000001
TOP: EX/MEM: ALU result=0x00000003 for rd=x7
TOP: MEM/WB: Writing back 0x00000003 to rd=x6
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x6, result_src=00
WBMUX: Selected ALU result: 0x00000003
ALU INPUT: rs1_data_i = 0x00000001 (bytes: 01 00 00 00)
ALU INPUT: rs2_data_i = 0x00000001 (bytes: 01 00 00 00)
ALU INPUT: alu_op_in = 0010
ALU SLL: 0x00000001 << 0x01 = 0x00000002
ALU OUTPUT: alu_res_d = 0x00000002 (bytes: 02 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x0000002c, mem_index=11, instruction=0x4020d513
ALU OUTPUT: alu_res_d = 0x00000002 (bytes=02 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
TOP: About to write to register x6, value=0x00000003, reg_write_en=1
TOP: TOP: About to write to register x6, value=0x00000003, reg_write_en=1
TOP: Executed instruction 10: 0x0020d493 at PC=0x00000028
DECODE: Instruction: 0x0020d493
DECODE: Opcode: 0x13, funct3: 0x5, funct7: 0x00
DECODE: rs1: x1, rs2: x2, rd: x9
REGFILE: Writing 0x00000003 to x6
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x00000003, rd=x7
TOP: IF/ID: Loading instruction 0x4020d513 from PC 0x0000002c
TOP: ID/EX: Processing instruction 0x0020d493
TOP: ID/EX: rs1=x1 (0x00000001), rs2=x2 (0x00000002), rd=x9
TOP: ID/EX: imm=0x00000002
TOP: EX/MEM: ALU result=0x00000002 for rd=x8
TOP: MEM/WB: Writing back 0x00000003 to rd=x7
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x7, result_src=00
WBMUX: Selected ALU result: 0x00000003
ALU INPUT: rs1_data_i = 0x00000001 (bytes: 01 00 00 00)
ALU INPUT: rs2_data_i = 0x00000002 (bytes: 02 00 00 00)
ALU INPUT: alu_op_in = 0110
ALU SRL: 0x00000001 >> 0x02 = 0x00000000
ALU OUTPUT: alu_res_d = 0x00000000 (bytes: 00 00 00 00)
ALU FLAGS: zero=1, negative=0, overflow=0
IMEM: Reading from address 0x00000030, mem_index=12, instruction=0x00302023
ALU OUTPUT: alu_res_d = 0x00000000 (bytes=00 00 00 00)
ALU FLAGS: zero=1, negative=0, overflow=0
TOP: About to write to register x7, value=0x00000003, reg_write_en=1
TOP: TOP: About to write to register x7, value=0x00000003, reg_write_en=1
TOP: Executed instruction 11: 0x4020d513 at PC=0x0000002c
DECODE: Instruction: 0x4020d513
DECODE: Opcode: 0x13, funct3: 0x5, funct7: 0x20
DECODE: rs1: x1, rs2: x2, rd: x10
REGFILE: Writing 0x00000003 to x7
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x00000002, rd=x8
TOP: IF/ID: Loading instruction 0x00302023 from PC 0x00000030
TOP: ID/EX: Processing instruction 0x4020d513
TOP: ID/EX: rs1=x1 (0x00000001), rs2=x2 (0x00000002), rd=x10
TOP: ID/EX: imm=0x00000402
TOP: EX/MEM: ALU result=0x00000000 for rd=x9
TOP: MEM/WB: Writing back 0x00000002 to rd=x8
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x8, result_src=00
WBMUX: Selected ALU result: 0x00000002
ALU INPUT: rs1_data_i = 0x00000001 (bytes: 01 00 00 00)
ALU INPUT: rs2_data_i = 0x00000402 (bytes: 02 04 00 00)
ALU INPUT: alu_op_in = 0111
ALU SRA: 0x00000001 >>> 0x02 = 0x00000000
ALU OUTPUT: alu_res_d = 0x00000000 (bytes: 00 00 00 00)
ALU FLAGS: zero=1, negative=0, overflow=0
IMEM: Reading from address 0x00000034, mem_index=13, instruction=0x00402223
TOP: About to write to register x8, value=0x00000002, reg_write_en=1
TOP: TOP: About to write to register x8, value=0x00000002, reg_write_en=1
TOP: STORE INSTRUCTION DETECTED: SW x3, 0(x0)
TOP:   Current value of x3: 0x00000003
TOP: Executed instruction 12: 0x00302023 at PC=0x00000030
DECODE: Instruction: 0x00302023
DECODE: Opcode: 0x23, funct3: 0x2, funct7: 0x00
DECODE: rs1: x0, rs2: x3, rd: x0
REGFILE: Writing 0x00000002 to x8
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x00000000, rd=x9
TOP: IF/ID: Loading instruction 0x00402223 from PC 0x00000034
TOP: ID/EX: Processing instruction 0x00302023
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x3 (0x00000003), rd=x0
TOP: ID/EX: imm=0x00000000
TOP: EX/MEM: ALU result=0x00000000 for rd=x10
TOP: MEM/WB: Writing back 0x00000000 to rd=x9
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x9, result_src=00
WBMUX: Selected ALU result: 0x00000000
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000000 = 0x00000000 (decimal: 0 + 0 = 0)
ALU ADD RESULT BYTES: 00 00 00 00
ALU OUTPUT: alu_res_d = 0x00000000 (bytes: 00 00 00 00)
ALU FLAGS: zero=1, negative=0, overflow=0
IMEM: Reading from address 0x00000038, mem_index=14, instruction=0x00002583
TOP: STORE INSTRUCTION IN EX STAGE: instr=0x00302023, rs2_addr=x3, rs2_data=0x00000003
TOP: About to write to register x9, value=0x00000000, reg_write_en=1
TOP: TOP: About to write to register x9, value=0x00000000, reg_write_en=1
TOP: Executed instruction 13: 0x00402223 at PC=0x00000034
DECODE: Instruction: 0x00402223
DECODE: Opcode: 0x23, funct3: 0x2, funct7: 0x00
DECODE: rs1: x0, rs2: x4, rd: x4
REGFILE: Writing 0x00000000 to x9
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x00000000, rd=x10
TOP: IF/ID: Loading instruction 0x00002583 from PC 0x00000038
TOP: ID/EX: Processing instruction 0x00402223
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x4 (0xfffffffe), rd=x4
TOP: ID/EX: imm=0x00000004
TOP: STORE INSTRUCTION MOVING TO MEM STAGE:
TOP:   rs2_addr=x3, forwarded=0, forward_sel=00
TOP:   Original rs2_data=0x00000003
TOP: MEM/WB: Writing back 0x00000000 to rd=x10
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x10, result_src=00
WBMUX: Selected ALU result: 0x00000000
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000004 (bytes: 04 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000004 = 0x00000004 (decimal: 0 + 4 = 4)
ALU ADD RESULT BYTES: 04 00 00 00
ALU OUTPUT: alu_res_d = 0x00000004 (bytes: 04 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x0000003c, mem_index=15, instruction=0x00b00593
ALU OUTPUT: alu_res_d = 0x00000004 (bytes=04 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
TOP: STORE INSTRUCTION IN EX STAGE: instr=0x00402223, rs2_addr=x4, rs2_data=0xfffffffe
TOP: MEMORY STORE EXECUTION: addr=0x00000000, data=0x00000003
TOP:   MEMORY STORE TO ADDRESS 0: Storing value 0x00000003
TOP:   SUCCESS: Correctly storing value 3 from register x3
TOP: MEMORY WRITE OPERATION: addr=0x00000000, data=0x00000003, size=2
TOP: About to write to register x10, value=0x00000000, reg_write_en=1
TOP: TOP: About to write to register x10, value=0x00000000, reg_write_en=1
TOP: MEMORY WRITE EXECUTING: addr=0x00000000, data=0x00000003
TOP: 
EXECUTING MEMORY STORE: addr=0x00000000, data=0x00000003
TOP:   STORE INSTRUCTION: Using rs2=x3 (value=0x00000003)
TOP:   CRITICAL STORE TO ADDRESS 0: val=0x00000003
TOP: VERIFICATION: About to store 0x00000003 to address 0
TOP: Executed instruction 14: 0x00002583 at PC=0x00000038
DECODE: Instruction: 0x00002583
DECODE: Opcode: 0x03, funct3: 0x2, funct7: 0x00
DECODE: rs1: x0, rs2: x0, rd: x11
DMEM: SAVE INSTRUCTION DETECTED
DMEM: INSTRUCTION: 0x00302023
DMEM: MEMORY DEBUG: Writing to address 0x00000000, data=0x00000003, size=2
DMEM: MEMORY WRITE WORD: addr=0x00000000, data=0x00000003
DMEM:   Writing bytes: 03 00 00 00
DMEM: ** MEMORY STORE: WORD 0x00000003 written to address 0x00000000 **
DMEM: MEMORY POST-WRITE CHECK: Address 0x00000000 now contains bytes: 00 00 00 00
REGFILE: Writing 0x00000000 to x10
TOP: IF/ID: Loading instruction 0x00b00593 from PC 0x0000003c
TOP: ID/EX: Processing instruction 0x00002583
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x0 (0x00000000), rd=x11
TOP: ID/EX: imm=0x00000000
TOP: STORE INSTRUCTION MOVING TO MEM STAGE:
TOP:   rs2_addr=x4, forwarded=0, forward_sel=00
TOP:   Original rs2_data=0xfffffffe
WBMUX: Selected ALU result: 0x00000000
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000000 = 0x00000000 (decimal: 0 + 0 = 0)
ALU ADD RESULT BYTES: 00 00 00 00
ALU OUTPUT: alu_res_d = 0x00000000 (bytes: 00 00 00 00)
ALU FLAGS: zero=1, negative=0, overflow=0
IMEM: Reading from address 0x00000040, mem_index=16, instruction=0x00402603
ALU OUTPUT: alu_res_d = 0x00000000 (bytes=00 00 00 00)
ALU FLAGS: zero=1, negative=0, overflow=0
TOP: MEMORY STORE EXECUTION: addr=0x00000004, data=0xfffffffe
TOP: MEMORY WRITE OPERATION: addr=0x00000004, data=0xfffffffe, size=2
TOP: MEMORY WRITE EXECUTING: addr=0x00000004, data=0xfffffffe
TOP: 
EXECUTING MEMORY STORE: addr=0x00000004, data=0xfffffffe
TOP:   STORE INSTRUCTION: Using rs2=x4 (value=0xfffffffe)
TOP: Executed instruction 15: 0x00b00593 at PC=0x0000003c
DECODE: Instruction: 0x00b00593
DECODE: Opcode: 0x13, funct3: 0x0, funct7: 0x00
DECODE: rs1: x0, rs2: x11, rd: x11
DMEM: SAVE INSTRUCTION DETECTED
DMEM: INSTRUCTION: 0x00402223
DMEM: MEMORY DEBUG: Writing to address 0x00000004, data=0xfffffffe, size=2
DMEM: MEMORY WRITE WORD: addr=0x00000004, data=0xfffffffe
DMEM:   Writing bytes: fe ff ff ff
DMEM: ** MEMORY STORE: WORD 0xfffffffe written to address 0x00000004 **
DMEM: MEMORY POST-WRITE CHECK: Address 0x00000004 now contains bytes: 00 00 00 00
TOP: IF/ID: Loading instruction 0x00402603 from PC 0x00000040
TOP: ID/EX: Processing instruction 0x00b00593
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x11 (0x00000000), rd=x11
TOP: ID/EX: imm=0x0000000b
TOP: EX/MEM: ALU result=0x00000000 for rd=x11
DMEM: LOAD INSTRUCTION DETECTED
DMEM: MEMORY DEBUG: Reading from address 0x00000000
DMEM: INSTRUCTION: 0x00002583
DMEM: PC: 0x00000038
DMEM: MEMORY READ WORD: addr=0x00000000, data=0x00000003
DMEM:   Final register value: 0x00000003
DMEM: MEMORY STATUS: Memory[3:0] = 03 00 00 00
WBMUX: Selected ALU result: 0x00000004
FWD: Forwarding rs2 from MEM stage: x11
TOP: Using forwarded RS2: forward_b=10, value=0x00000000
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x0000000b (bytes: 0b 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x0000000b = 0x0000000b (decimal: 0 + 11 = 11)
ALU ADD RESULT BYTES: 0b 00 00 00
ALU OUTPUT: alu_res_d = 0x0000000b (bytes: 0b 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x00000044, mem_index=17, instruction=0x00c58633
ALU OUTPUT: alu_res_d = 0x0000000b (bytes=0b 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
DMEM: MEMORY CONTENTS after write at addr=0x00000004:
DMEM:   Memory[7:4] = fe ff ff ff
DMEM:   Reconstructed word: 0xfffffffe
TOP: MEMORY READ OPERATION: addr=0x00000000, size=2
TOP: 
EXECUTING MEMORY LOAD: addr=0x00000000
TOP:   CRITICAL LOAD FROM ADDRESS 0
TOP:   Memory contents: 03 00 00 00
TOP: Executed instruction 16: 0x00402603 at PC=0x00000040
DECODE: Instruction: 0x00402603
DECODE: Opcode: 0x03, funct3: 0x2, funct7: 0x00
DECODE: rs1: x0, rs2: x4, rd: x12
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x00000000, rd=x11
TOP: IF/ID: Loading instruction 0x00c58633 from PC 0x00000044
TOP: ID/EX: Processing instruction 0x00402603
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x4 (0xfffffffe), rd=x12
TOP: ID/EX: imm=0x00000004
TOP: EX/MEM: ALU result=0x0000000b for rd=x11
TOP: MEM/WB: Memory read data=0x00000003 from addr=0x00000000
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x11, result_src=01
WBMUX: Selected Memory data: 0x00000003
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000004 (bytes: 04 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000004 = 0x00000004 (decimal: 0 + 4 = 4)
ALU ADD RESULT BYTES: 04 00 00 00
ALU OUTPUT: alu_res_d = 0x00000004 (bytes: 04 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x00000048, mem_index=18, instruction=0x00c02423
HAZARD DETECTED: Load-use hazard. Stalling pipeline.
  Load to register x12, followed by use in rs1=11 or rs2=12
ALU OUTPUT: alu_res_d = 0x00000004 (bytes=04 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
DMEM: MEMORY CONTENTS after write at addr=0x00000004:
DMEM:   Memory[7:4] = fe ff ff ff
DMEM:   Reconstructed word: 0xfffffffe
TOP: About to write to register x11, value=0x00000003, reg_write_en=1
TOP: TOP: About to write to register x11, value=0x00000003, reg_write_en=1
TOP: VERIFICATION: Loaded 0x00000003 from address 0
TOP: VERIFICATION PASSED: Successfully loaded correct value (3) from address 0
DECODE: Instruction: 0x00c58633
DECODE: Opcode: 0x33, funct3: 0x0, funct7: 0x00
DECODE: rs1: x11, rs2: x12, rd: x12
REGFILE: Writing 0x00000003 to x11
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x0000000b, rd=x11
TOP: IF/ID: Stalled (keeping current values)
TOP: ID/EX: Inserting NOP due to stall
TOP: EX/MEM: ALU result=0x00000004 for rd=x12
TOP: MEM/WB: Writing back 0x0000000b to rd=x11
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x11, result_src=00
DMEM: LOAD INSTRUCTION DETECTED
DMEM: MEMORY DEBUG: Reading from address 0x00000004
DMEM: INSTRUCTION: 0x00402603
DMEM: PC: 0x00000040
DMEM: MEMORY READ WORD: addr=0x00000004, data=0xfffffffe
DMEM:   Final register value: 0xfffffffe
DMEM: MEMORY STATUS: Memory[7:4] = fe ff ff ff
WBMUX: Selected ALU result: 0x0000000b
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000004 (bytes: 04 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000004 = 0x00000004 (decimal: 0 + 4 = 4)
ALU ADD RESULT BYTES: 04 00 00 00
ALU OUTPUT: alu_res_d = 0x00000004 (bytes: 04 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x00000048, mem_index=18, instruction=0x00c02423
TOP: MEMORY READ OPERATION: addr=0x00000004, size=2
TOP: About to write to register x11, value=0x0000000b, reg_write_en=1
TOP: TOP: About to write to register x11, value=0x0000000b, reg_write_en=1
TOP: 
EXECUTING MEMORY LOAD: addr=0x00000004
TOP: Executed instruction 17: 0x00c58633 at PC=0x00000044
DECODE: Instruction: 0x00c58633
DECODE: Opcode: 0x33, funct3: 0x0, funct7: 0x00
DECODE: rs1: x11, rs2: x12, rd: x12
REGFILE: Writing 0x0000000b to x11
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x00000004, rd=x12
TOP: IF/ID: Loading instruction 0x00c02423 from PC 0x00000048
TOP: ID/EX: Processing instruction 0x00c58633
TOP: ID/EX: rs1=x11 (0x0000000b), rs2=x12 (0x00000000), rd=x12
TOP: MEM/WB: Memory read data=0xfffffffe from addr=0x00000004
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x12, result_src=01
WBMUX: Selected Memory data: 0xfffffffe
FWD: Forwarding rs2 from WB stage: x12
TOP: Using forwarded RS2: forward_b=01, value=0xfffffffe
ALU INPUT: rs1_data_i = 0x0000000b (bytes: 0b 00 00 00)
ALU INPUT: rs2_data_i = 0xfffffffe (bytes: fe ff ff ff)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x0000000b + 0xfffffffe = 0x00000009 (decimal: 11 + -2 = 9)
ALU ADD RESULT BYTES: 09 00 00 00
ALU OUTPUT: alu_res_d = 0x00000009 (bytes: 09 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x0000004c, mem_index=19, instruction=0x00802683
ALU OUTPUT: alu_res_d = 0x00000009 (bytes=09 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
TOP: About to write to register x12, value=0xfffffffe, reg_write_en=1
TOP: TOP: About to write to register x12, value=0xfffffffe, reg_write_en=1
TOP: Executed instruction 18: 0x00c02423 at PC=0x00000048
DECODE: Instruction: 0x00c02423
DECODE: Opcode: 0x23, funct3: 0x2, funct7: 0x00
DECODE: rs1: x0, rs2: x12, rd: x8
REGFILE: Writing 0xfffffffe to x12
TOP: IF/ID: Loading instruction 0x00802683 from PC 0x0000004c
TOP: ID/EX: Processing instruction 0x00c02423
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x12 (0xfffffffe), rd=x8
TOP: ID/EX: imm=0x00000008
TOP: EX/MEM: ALU result=0x00000009 for rd=x12
WBMUX: Selected Memory data: 0x00000000
FWD: Forwarding rs2 from MEM stage: x12
TOP: Using forwarded RS2: forward_b=10, value=0x00000009
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000008 (bytes: 08 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000008 = 0x00000008 (decimal: 0 + 8 = 8)
ALU ADD RESULT BYTES: 08 00 00 00
ALU OUTPUT: alu_res_d = 0x00000008 (bytes: 08 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x00000050, mem_index=20, instruction=0x00d106b3
ALU OUTPUT: alu_res_d = 0x00000008 (bytes=08 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
TOP: STORE INSTRUCTION IN EX STAGE: instr=0x00c02423, rs2_addr=x12, rs2_data=0xfffffffe
TOP: STORE FORWARDING ACTIVE: forward_b=10
TOP: Executed instruction 19: 0x00802683 at PC=0x0000004c
DECODE: Instruction: 0x00802683
DECODE: Opcode: 0x03, funct3: 0x2, funct7: 0x00
DECODE: rs1: x0, rs2: x8, rd: x13
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x00000009, rd=x12
TOP: IF/ID: Loading instruction 0x00d106b3 from PC 0x00000050
TOP: ID/EX: Processing instruction 0x00802683
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x8 (0x00000002), rd=x13
TOP: ID/EX: imm=0x00000008
TOP: STORE INSTRUCTION MOVING TO MEM STAGE:
TOP:   rs2_addr=x12, forwarded=1, forward_sel=10
TOP:   Original rs2_data=0xfffffffe
TOP:   Forwarded rs2_data from MEM=0x00000009
TOP: MEM/WB: Writing back 0x00000009 to rd=x12
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x12, result_src=00
WBMUX: Selected ALU result: 0x00000009
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000008 (bytes: 08 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000008 = 0x00000008 (decimal: 0 + 8 = 8)
ALU ADD RESULT BYTES: 08 00 00 00
ALU OUTPUT: alu_res_d = 0x00000008 (bytes: 08 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x00000054, mem_index=21, instruction=0x00d02623
HAZARD DETECTED: Load-use hazard. Stalling pipeline.
  Load to register x13, followed by use in rs1=2 or rs2=13
TOP: MEMORY STORE EXECUTION: addr=0x00000008, data=0x00000009
TOP: MEMORY WRITE OPERATION: addr=0x00000008, data=0x00000009, size=2
TOP: About to write to register x12, value=0x00000009, reg_write_en=1
TOP: TOP: About to write to register x12, value=0x00000009, reg_write_en=1
TOP: MEMORY WRITE EXECUTING: addr=0x00000008, data=0x00000009
TOP: 
EXECUTING MEMORY STORE: addr=0x00000008, data=0x00000009
TOP:   STORE INSTRUCTION: Using rs2=x12 (value=0x00000009)
DECODE: Instruction: 0x00d106b3
DECODE: Opcode: 0x33, funct3: 0x0, funct7: 0x00
DECODE: rs1: x2, rs2: x13, rd: x13
DMEM: SAVE INSTRUCTION DETECTED
DMEM: INSTRUCTION: 0x00c02423
DMEM: MEMORY DEBUG: Writing to address 0x00000008, data=0x00000009, size=2
DMEM: MEMORY WRITE WORD: addr=0x00000008, data=0x00000009
DMEM:   Writing bytes: 09 00 00 00
DMEM: ** MEMORY STORE: WORD 0x00000009 written to address 0x00000008 **
DMEM: MEMORY POST-WRITE CHECK: Address 0x00000008 now contains bytes: 00 00 00 00
REGFILE: Writing 0x00000009 to x12
TOP: IF/ID: Stalled (keeping current values)
TOP: ID/EX: Inserting NOP due to stall
TOP: EX/MEM: ALU result=0x00000008 for rd=x13
DMEM: LOAD INSTRUCTION DETECTED
DMEM: MEMORY DEBUG: Reading from address 0x00000008
DMEM: INSTRUCTION: 0x00802683
DMEM: PC: 0x0000004c
DMEM: MEMORY READ WORD: addr=0x00000008, data=0x00000009
DMEM:   Final register value: 0x00000009
DMEM: MEMORY STATUS: Memory[11:8] = 09 00 00 00
WBMUX: Selected ALU result: 0x00000008
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000008 (bytes: 08 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000008 = 0x00000008 (decimal: 0 + 8 = 8)
ALU ADD RESULT BYTES: 08 00 00 00
ALU OUTPUT: alu_res_d = 0x00000008 (bytes: 08 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x00000054, mem_index=21, instruction=0x00d02623
TOP: MEMORY READ OPERATION: addr=0x00000008, size=2
TOP: 
EXECUTING MEMORY LOAD: addr=0x00000008
TOP: Executed instruction 20: 0x00d106b3 at PC=0x00000050
DECODE: Instruction: 0x00d106b3
DECODE: Opcode: 0x33, funct3: 0x0, funct7: 0x00
DECODE: rs1: x2, rs2: x13, rd: x13
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x00000008, rd=x13
TOP: IF/ID: Loading instruction 0x00d02623 from PC 0x00000054
TOP: ID/EX: Processing instruction 0x00d106b3
TOP: ID/EX: rs1=x2 (0x00000002), rs2=x13 (0x00000000), rd=x13
TOP: MEM/WB: Memory read data=0x00000009 from addr=0x00000008
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x13, result_src=01
WBMUX: Selected Memory data: 0x00000009
FWD: Forwarding rs2 from WB stage: x13
TOP: Using forwarded RS2: forward_b=01, value=0x00000009
ALU INPUT: rs1_data_i = 0x00000002 (bytes: 02 00 00 00)
ALU INPUT: rs2_data_i = 0x00000009 (bytes: 09 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000002 + 0x00000009 = 0x0000000b (decimal: 2 + 9 = 11)
ALU ADD RESULT BYTES: 0b 00 00 00
ALU OUTPUT: alu_res_d = 0x0000000b (bytes: 0b 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x00000058, mem_index=22, instruction=0x0fd00713
ALU OUTPUT: alu_res_d = 0x0000000b (bytes=0b 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
DMEM: MEMORY CONTENTS after write at addr=0x00000008:
DMEM:   Memory[11:8] = 09 00 00 00
DMEM:   Reconstructed word: 0x00000009
TOP: About to write to register x13, value=0x00000009, reg_write_en=1
TOP: TOP: About to write to register x13, value=0x00000009, reg_write_en=1
TOP: Executed instruction 21: 0x00d02623 at PC=0x00000054
DECODE: Instruction: 0x00d02623
DECODE: Opcode: 0x23, funct3: 0x2, funct7: 0x00
DECODE: rs1: x0, rs2: x13, rd: x12
REGFILE: Writing 0x00000009 to x13
TOP: IF/ID: Loading instruction 0x0fd00713 from PC 0x00000058
TOP: ID/EX: Processing instruction 0x00d02623
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x13 (0x00000009), rd=x12
TOP: ID/EX: imm=0x0000000c
TOP: EX/MEM: ALU result=0x0000000b for rd=x13
WBMUX: Selected Memory data: 0x00000000
FWD: Forwarding rs2 from MEM stage: x13
TOP: Using forwarded RS2: forward_b=10, value=0x0000000b
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x0000000c (bytes: 0c 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x0000000c = 0x0000000c (decimal: 0 + 12 = 12)
ALU ADD RESULT BYTES: 0c 00 00 00
ALU OUTPUT: alu_res_d = 0x0000000c (bytes: 0c 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x0000005c, mem_index=23, instruction=0x00e02823
ALU OUTPUT: alu_res_d = 0x0000000c (bytes=0c 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
TOP: STORE INSTRUCTION IN EX STAGE: instr=0x00d02623, rs2_addr=x13, rs2_data=0x00000009
TOP: STORE FORWARDING ACTIVE: forward_b=10
TOP: Executed instruction 22: 0x0fd00713 at PC=0x00000058
DECODE: Instruction: 0x0fd00713
DECODE: Opcode: 0x13, funct3: 0x0, funct7: 0x07
DECODE: rs1: x0, rs2: x29, rd: x14
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x0000000b, rd=x13
TOP: IF/ID: Loading instruction 0x00e02823 from PC 0x0000005c
TOP: ID/EX: Processing instruction 0x0fd00713
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x29 (0x00000000), rd=x14
TOP: ID/EX: imm=0x000000fd
TOP: STORE INSTRUCTION MOVING TO MEM STAGE:
TOP:   rs2_addr=x13, forwarded=1, forward_sel=10
TOP:   Original rs2_data=0x00000009
TOP:   Forwarded rs2_data from MEM=0x0000000b
TOP: MEM/WB: Writing back 0x0000000b to rd=x13
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x13, result_src=00
WBMUX: Selected ALU result: 0x0000000b
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x000000fd (bytes: fd 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x000000fd = 0x000000fd (decimal: 0 + 253 = 253)
ALU ADD RESULT BYTES: fd 00 00 00
ALU OUTPUT: alu_res_d = 0x000000fd (bytes: fd 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x00000060, mem_index=24, instruction=0x01000783
ALU OUTPUT: alu_res_d = 0x000000fd (bytes=fd 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
TOP: MEMORY STORE EXECUTION: addr=0x0000000c, data=0x0000000b
TOP: MEMORY WRITE OPERATION: addr=0x0000000c, data=0x0000000b, size=2
TOP: About to write to register x13, value=0x0000000b, reg_write_en=1
TOP: TOP: About to write to register x13, value=0x0000000b, reg_write_en=1
TOP: MEMORY WRITE EXECUTING: addr=0x0000000c, data=0x0000000b
TOP: 
EXECUTING MEMORY STORE: addr=0x0000000c, data=0x0000000b
TOP:   STORE INSTRUCTION: Using rs2=x13 (value=0x0000000b)
TOP: Executed instruction 23: 0x00e02823 at PC=0x0000005c
DECODE: Instruction: 0x00e02823
DECODE: Opcode: 0x23, funct3: 0x2, funct7: 0x00
DECODE: rs1: x0, rs2: x14, rd: x16
DMEM: SAVE INSTRUCTION DETECTED
DMEM: INSTRUCTION: 0x00d02623
DMEM: MEMORY DEBUG: Writing to address 0x0000000c, data=0x0000000b, size=2
DMEM: MEMORY WRITE WORD: addr=0x0000000c, data=0x0000000b
DMEM:   Writing bytes: 0b 00 00 00
DMEM: ** MEMORY STORE: WORD 0x0000000b written to address 0x0000000c **
DMEM: MEMORY POST-WRITE CHECK: Address 0x0000000c now contains bytes: 00 00 00 00
REGFILE: Writing 0x0000000b to x13
TOP: IF/ID: Loading instruction 0x01000783 from PC 0x00000060
TOP: ID/EX: Processing instruction 0x00e02823
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x14 (0x00000000), rd=x16
TOP: ID/EX: imm=0x00000010
TOP: EX/MEM: ALU result=0x000000fd for rd=x14
WBMUX: Selected ALU result: 0x0000000c
FWD: Forwarding rs2 from MEM stage: x14
TOP: Using forwarded RS2: forward_b=10, value=0x000000fd
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000010 (bytes: 10 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000010 = 0x00000010 (decimal: 0 + 16 = 16)
ALU ADD RESULT BYTES: 10 00 00 00
ALU OUTPUT: alu_res_d = 0x00000010 (bytes: 10 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x00000064, mem_index=25, instruction=0x01004803
ALU OUTPUT: alu_res_d = 0x00000010 (bytes=10 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
TOP: STORE INSTRUCTION IN EX STAGE: instr=0x00e02823, rs2_addr=x14, rs2_data=0x00000000
TOP: STORE FORWARDING ACTIVE: forward_b=10
TOP: Executed instruction 24: 0x01000783 at PC=0x00000060
DECODE: Instruction: 0x01000783
DECODE: Opcode: 0x03, funct3: 0x0, funct7: 0x00
DECODE: rs1: x0, rs2: x16, rd: x15
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x000000fd, rd=x14
TOP: IF/ID: Loading instruction 0x01004803 from PC 0x00000064
TOP: ID/EX: Processing instruction 0x01000783
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x16 (0x00000000), rd=x15
TOP: ID/EX: imm=0x00000010
TOP: STORE INSTRUCTION MOVING TO MEM STAGE:
TOP:   rs2_addr=x14, forwarded=1, forward_sel=10
TOP:   Original rs2_data=0x00000000
TOP:   Forwarded rs2_data from MEM=0x000000fd
TOP: MEM/WB: Writing back 0x000000fd to rd=x14
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x14, result_src=00
WBMUX: Selected ALU result: 0x000000fd
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000010 (bytes: 10 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000010 = 0x00000010 (decimal: 0 + 16 = 16)
ALU ADD RESULT BYTES: 10 00 00 00
ALU OUTPUT: alu_res_d = 0x00000010 (bytes: 10 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x00000068, mem_index=26, instruction=0xaaaab837
DMEM: MEMORY CONTENTS after write at addr=0x0000000c:
DMEM:   Memory[15:12] = 0b 00 00 00
DMEM:   Reconstructed word: 0x0000000b
TOP: MEMORY STORE EXECUTION: addr=0x00000010, data=0x000000fd
TOP: MEMORY WRITE OPERATION: addr=0x00000010, data=0x000000fd, size=2
TOP: About to write to register x14, value=0x000000fd, reg_write_en=1
TOP: TOP: About to write to register x14, value=0x000000fd, reg_write_en=1
TOP: MEMORY WRITE EXECUTING: addr=0x00000010, data=0x000000fd
TOP: 
EXECUTING MEMORY STORE: addr=0x00000010, data=0x000000fd
TOP:   STORE INSTRUCTION: Using rs2=x14 (value=0x000000fd)
TOP: Executed instruction 25: 0x01004803 at PC=0x00000064
DECODE: Instruction: 0x01004803
DECODE: Opcode: 0x03, funct3: 0x4, funct7: 0x00
DECODE: rs1: x0, rs2: x16, rd: x16
DMEM: SAVE INSTRUCTION DETECTED
DMEM: INSTRUCTION: 0x00e02823
DMEM: MEMORY DEBUG: Writing to address 0x00000010, data=0x000000fd, size=2
DMEM: MEMORY WRITE WORD: addr=0x00000010, data=0x000000fd
DMEM:   Writing bytes: fd 00 00 00
DMEM: ** MEMORY STORE: WORD 0x000000fd written to address 0x00000010 **
DMEM: MEMORY POST-WRITE CHECK: Address 0x00000010 now contains bytes: 00 00 00 00
REGFILE: Writing 0x000000fd to x14
TOP: IF/ID: Loading instruction 0xaaaab837 from PC 0x00000068
TOP: ID/EX: Processing instruction 0x01004803
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x16 (0x00000000), rd=x16
TOP: ID/EX: imm=0x00000010
TOP: EX/MEM: ALU result=0x00000010 for rd=x15
DMEM: LOAD INSTRUCTION DETECTED
DMEM: MEMORY DEBUG: Reading from address 0x00000010
DMEM: INSTRUCTION: 0x01000783
DMEM: PC: 0x00000060
DMEM: MEMORY READ BYTE: addr=0x00000010, data=fd
WBMUX: Selected ALU result: 0x00000010
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000010 (bytes: 10 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000010 = 0x00000010 (decimal: 0 + 16 = 16)
ALU ADD RESULT BYTES: 10 00 00 00
ALU OUTPUT: alu_res_d = 0x00000010 (bytes: 10 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x0000006c, mem_index=27, instruction=0x01002a23
TOP: MEMORY READ OPERATION: addr=0x00000010, size=0
TOP: 
EXECUTING MEMORY LOAD: addr=0x00000010
TOP: Executed instruction 26: 0xaaaab837 at PC=0x00000068
DECODE: Instruction: 0xaaaab837
DECODE: Opcode: 0x37, funct3: 0x3, funct7: 0x55
DECODE: rs1: x21, rs2: x10, rd: x16
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x00000010, rd=x15
TOP: IF/ID: Loading instruction 0x01002a23 from PC 0x0000006c
TOP: ID/EX: Processing instruction 0xaaaab837
TOP: ID/EX: rs1=x21 (0x00000000), rs2=x10 (0x00000000), rd=x16
TOP: ID/EX: imm=0xaaaab000
TOP: EX/MEM: ALU result=0x00000010 for rd=x16
TOP: MEM/WB: Memory read data=0xfffffffd from addr=0x00000010
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x15, result_src=01
DMEM: LOAD INSTRUCTION DETECTED
DMEM: MEMORY DEBUG: Reading from address 0x00000010
DMEM: INSTRUCTION: 0x01004803
DMEM: PC: 0x00000064
DMEM: MEMORY READ BYTE: addr=0x00000010, data=fd
WBMUX: Selected Memory data: 0xfffffffd
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0xaaaab000 (bytes: 00 b0 aa aa)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0xaaaab000 = 0xaaaab000 (decimal: 0 + -1431654400 = -1431654400)
ALU ADD RESULT BYTES: 00 b0 aa aa
ALU OUTPUT: alu_res_d = 0xaaaab000 (bytes: 00 b0 aa aa)
ALU FLAGS: zero=0, negative=1, overflow=0
IMEM: Reading from address 0x00000070, mem_index=28, instruction=0x01401883
ALU OUTPUT: alu_res_d = 0xaaaab000 (bytes=00 b0 aa aa)
ALU FLAGS: zero=0, negative=1, overflow=0
DMEM: MEMORY CONTENTS after write at addr=0x00000010:
DMEM:   Memory[19:16] = fd 00 00 00
DMEM:   Reconstructed word: 0x000000fd
TOP: MEMORY READ OPERATION: addr=0x00000010, size=0
TOP: About to write to register x15, value=0xfffffffd, reg_write_en=1
TOP: TOP: About to write to register x15, value=0xfffffffd, reg_write_en=1
TOP: 
EXECUTING MEMORY LOAD: addr=0x00000010
TOP: Executed instruction 27: 0x01002a23 at PC=0x0000006c
DECODE: Instruction: 0x01002a23
DECODE: Opcode: 0x23, funct3: 0x2, funct7: 0x00
DECODE: rs1: x0, rs2: x16, rd: x20
REGFILE: Writing 0xfffffffd to x15
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x00000010, rd=x16
TOP: IF/ID: Loading instruction 0x01401883 from PC 0x00000070
TOP: ID/EX: Processing instruction 0x01002a23
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x16 (0x00000000), rd=x20
TOP: ID/EX: imm=0x00000014
TOP: EX/MEM: ALU result=0xaaaab000 for rd=x16
TOP: MEM/WB: Memory read data=0xfffffffd from addr=0x00000010
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x16, result_src=01
WBMUX: Selected Memory data: 0xfffffffd
FWD: Forwarding rs2 from MEM stage: x16
TOP: Using forwarded RS2: forward_b=10, value=0xaaaab000
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000014 (bytes: 14 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000014 = 0x00000014 (decimal: 0 + 20 = 20)
ALU ADD RESULT BYTES: 14 00 00 00
ALU OUTPUT: alu_res_d = 0x00000014 (bytes: 14 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x00000074, mem_index=29, instruction=0x01405903
ALU OUTPUT: alu_res_d = 0x00000014 (bytes=14 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
TOP: STORE INSTRUCTION IN EX STAGE: instr=0x01002a23, rs2_addr=x16, rs2_data=0x00000000
TOP: STORE FORWARDING ACTIVE: forward_b=10
TOP: About to write to register x16, value=0xfffffffd, reg_write_en=1
TOP: TOP: About to write to register x16, value=0xfffffffd, reg_write_en=1
TOP: Executed instruction 28: 0x01401883 at PC=0x00000070
DECODE: Instruction: 0x01401883
DECODE: Opcode: 0x03, funct3: 0x1, funct7: 0x00
DECODE: rs1: x0, rs2: x20, rd: x17
REGFILE: Writing 0xfffffffd to x16
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0xaaaab000, rd=x16
TOP: IF/ID: Loading instruction 0x01405903 from PC 0x00000074
TOP: ID/EX: Processing instruction 0x01401883
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x20 (0x00000000), rd=x17
TOP: ID/EX: imm=0x00000014
TOP: STORE INSTRUCTION MOVING TO MEM STAGE:
TOP:   rs2_addr=x16, forwarded=1, forward_sel=10
TOP:   Original rs2_data=0x00000000
TOP:   Forwarded rs2_data from MEM=0xaaaab000
TOP: MEM/WB: Writing back 0xaaaab000 to rd=x16
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x16, result_src=00
WBMUX: Selected ALU result: 0xaaaab000
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000014 (bytes: 14 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000014 = 0x00000014 (decimal: 0 + 20 = 20)
ALU ADD RESULT BYTES: 14 00 00 00
ALU OUTPUT: alu_res_d = 0x00000014 (bytes: 14 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x00000078, mem_index=30, instruction=0x00300993
TOP: MEMORY STORE EXECUTION: addr=0x00000014, data=0xaaaab000
TOP: MEMORY WRITE OPERATION: addr=0x00000014, data=0xaaaab000, size=2
TOP: About to write to register x16, value=0xaaaab000, reg_write_en=1
TOP: TOP: About to write to register x16, value=0xaaaab000, reg_write_en=1
TOP: MEMORY WRITE EXECUTING: addr=0x00000014, data=0xaaaab000
TOP: 
EXECUTING MEMORY STORE: addr=0x00000014, data=0xaaaab000
TOP:   STORE INSTRUCTION: Using rs2=x16 (value=0xaaaab000)
TOP: Executed instruction 29: 0x01405903 at PC=0x00000074
DECODE: Instruction: 0x01405903
DECODE: Opcode: 0x03, funct3: 0x5, funct7: 0x00
DECODE: rs1: x0, rs2: x20, rd: x18
DMEM: SAVE INSTRUCTION DETECTED
DMEM: INSTRUCTION: 0x01002a23
DMEM: MEMORY DEBUG: Writing to address 0x00000014, data=0xaaaab000, size=2
DMEM: MEMORY WRITE WORD: addr=0x00000014, data=0xaaaab000
DMEM:   Writing bytes: 00 b0 aa aa
DMEM: ** MEMORY STORE: WORD 0xaaaab000 written to address 0x00000014 **
DMEM: MEMORY POST-WRITE CHECK: Address 0x00000014 now contains bytes: 00 00 00 00
REGFILE: Writing 0xaaaab000 to x16
TOP: IF/ID: Loading instruction 0x00300993 from PC 0x00000078
TOP: ID/EX: Processing instruction 0x01405903
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x20 (0x00000000), rd=x18
TOP: ID/EX: imm=0x00000014
TOP: EX/MEM: ALU result=0x00000014 for rd=x17
DMEM: LOAD INSTRUCTION DETECTED
DMEM: MEMORY DEBUG: Reading from address 0x00000014
DMEM: INSTRUCTION: 0x01401883
DMEM: PC: 0x00000070
DMEM: MEMORY READ HALFWORD: addr=0x00000014, data=b000
WBMUX: Selected ALU result: 0x00000014
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000014 (bytes: 14 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000014 = 0x00000014 (decimal: 0 + 20 = 20)
ALU ADD RESULT BYTES: 14 00 00 00
ALU OUTPUT: alu_res_d = 0x00000014 (bytes: 14 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x0000007c, mem_index=31, instruction=0x00500a13
TOP: MEMORY READ OPERATION: addr=0x00000014, size=1
TOP: 
EXECUTING MEMORY LOAD: addr=0x00000014
TOP: Executed instruction 30: 0x00300993 at PC=0x00000078
DECODE: Instruction: 0x00300993
DECODE: Opcode: 0x13, funct3: 0x0, funct7: 0x00
DECODE: rs1: x0, rs2: x3, rd: x19
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x00000014, rd=x17
TOP: IF/ID: Loading instruction 0x00500a13 from PC 0x0000007c
TOP: ID/EX: Processing instruction 0x00300993
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x3 (0x00000003), rd=x19
TOP: ID/EX: imm=0x00000003
TOP: EX/MEM: ALU result=0x00000014 for rd=x18
TOP: MEM/WB: Memory read data=0xffffb000 from addr=0x00000014
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x17, result_src=01
DMEM: LOAD INSTRUCTION DETECTED
DMEM: MEMORY DEBUG: Reading from address 0x00000014
DMEM: INSTRUCTION: 0x01405903
DMEM: PC: 0x00000074
DMEM: MEMORY READ HALFWORD: addr=0x00000014, data=b000
WBMUX: Selected Memory data: 0xffffb000
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000003 (bytes: 03 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000003 = 0x00000003 (decimal: 0 + 3 = 3)
ALU ADD RESULT BYTES: 03 00 00 00
ALU OUTPUT: alu_res_d = 0x00000003 (bytes: 03 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x00000080, mem_index=32, instruction=0x01498a63
ALU OUTPUT: alu_res_d = 0x00000003 (bytes=03 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
DMEM: MEMORY CONTENTS after write at addr=0x00000014:
DMEM:   Memory[23:20] = 00 b0 aa aa
DMEM:   Reconstructed word: 0xaaaab000
TOP: MEMORY READ OPERATION: addr=0x00000014, size=1
TOP: About to write to register x17, value=0xffffb000, reg_write_en=1
TOP: TOP: About to write to register x17, value=0xffffb000, reg_write_en=1
TOP: 
EXECUTING MEMORY LOAD: addr=0x00000014
TOP: Executed instruction 31: 0x00500a13 at PC=0x0000007c
DECODE: Instruction: 0x00500a13
DECODE: Opcode: 0x13, funct3: 0x0, funct7: 0x00
DECODE: rs1: x0, rs2: x5, rd: x20
REGFILE: Writing 0xffffb000 to x17
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x00000014, rd=x18
TOP: IF/ID: Loading instruction 0x01498a63 from PC 0x00000080
TOP: ID/EX: Processing instruction 0x00500a13
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x5 (0x00000000), rd=x20
TOP: ID/EX: imm=0x00000005
TOP: EX/MEM: ALU result=0x00000003 for rd=x19
TOP: MEM/WB: Memory read data=0xffffb000 from addr=0x00000014
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x18, result_src=01
WBMUX: Selected Memory data: 0xffffb000
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000005 (bytes: 05 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000005 = 0x00000005 (decimal: 0 + 5 = 5)
ALU ADD RESULT BYTES: 05 00 00 00
ALU OUTPUT: alu_res_d = 0x00000005 (bytes: 05 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x00000084, mem_index=33, instruction=0x01400a93
ALU OUTPUT: alu_res_d = 0x00000005 (bytes=05 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
TOP: About to write to register x18, value=0xffffb000, reg_write_en=1
TOP: TOP: About to write to register x18, value=0xffffb000, reg_write_en=1
TOP: Executed instruction 32: 0x01498a63 at PC=0x00000080
DECODE: Instruction: 0x01498a63
DECODE: Opcode: 0x63, funct3: 0x0, funct7: 0x00
DECODE: rs1: x19, rs2: x20, rd: x20
REGFILE: Writing 0xffffb000 to x18
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x00000003, rd=x19
TOP: IF/ID: Loading instruction 0x01400a93 from PC 0x00000084
TOP: ID/EX: Processing instruction 0x01498a63
TOP: ID/EX: rs1=x19 (0x00000000), rs2=x20 (0x00000000), rd=x20
TOP: ID/EX: imm=0x00000014
TOP: EX/MEM: ALU result=0x00000005 for rd=x20
TOP: MEM/WB: Writing back 0x00000003 to rd=x19
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x19, result_src=00
WBMUX: Selected ALU result: 0x00000003
FWD: Forwarding rs1 from WB stage: x19
FWD: Forwarding rs2 from MEM stage: x20
TOP: Using forwarded RS1: forward_a=01, value=0x00000003
TOP: Using forwarded RS2: forward_b=10, value=0x00000005
ALU INPUT: rs1_data_i = 0x00000003 (bytes: 03 00 00 00)
ALU INPUT: rs2_data_i = 0x00000014 (bytes: 14 00 00 00)
ALU INPUT: alu_op_in = 1010
ALU BEQ: 0x00000003 == 0x00000014 = 0
ALU OUTPUT: alu_res_d = 0xffffffef (bytes: ef ff ff ff)
ALU FLAGS: zero=0, negative=1, overflow=0
IMEM: Reading from address 0x00000088, mem_index=34, instruction=0x01499463
ALU OUTPUT: alu_res_d = 0xffffffef (bytes=ef ff ff ff)
ALU FLAGS: zero=0, negative=1, overflow=0
TOP: About to write to register x19, value=0x00000003, reg_write_en=1
TOP: TOP: About to write to register x19, value=0x00000003, reg_write_en=1
TOP: Executed instruction 33: 0x01400a93 at PC=0x00000084
DECODE: Instruction: 0x01400a93
DECODE: Opcode: 0x13, funct3: 0x0, funct7: 0x00
DECODE: rs1: x0, rs2: x20, rd: x21
REGFILE: Writing 0x00000003 to x19
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x00000005, rd=x20
TOP: IF/ID: Loading instruction 0x01499463 from PC 0x00000088
TOP: ID/EX: Processing instruction 0x01400a93
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x20 (0x00000000), rd=x21
TOP: ID/EX: imm=0x00000014
TOP: EX/MEM: Branch condition=0
TOP: MEM/WB: Writing back 0x00000005 to rd=x20
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x20, result_src=00
WBMUX: Selected ALU result: 0x00000005
FWD: Forwarding rs2 from WB stage: x20
TOP: Using forwarded RS2: forward_b=01, value=0x00000005
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000014 (bytes: 14 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000014 = 0x00000014 (decimal: 0 + 20 = 20)
ALU ADD RESULT BYTES: 14 00 00 00
ALU OUTPUT: alu_res_d = 0x00000014 (bytes: 14 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x0000008c, mem_index=35, instruction=0xfff00b13
ALU OUTPUT: alu_res_d = 0x00000014 (bytes=14 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
TOP: About to write to register x20, value=0x00000005, reg_write_en=1
TOP: TOP: About to write to register x20, value=0x00000005, reg_write_en=1
TOP: Executed instruction 34: 0x01499463 at PC=0x00000088
DECODE: Instruction: 0x01499463
DECODE: Opcode: 0x63, funct3: 0x1, funct7: 0x00
DECODE: rs1: x19, rs2: x20, rd: x8
REGFILE: Writing 0x00000005 to x20
TOP: IF/ID: Loading instruction 0xfff00b13 from PC 0x0000008c
TOP: ID/EX: Processing instruction 0x01499463
TOP: ID/EX: rs1=x19 (0x00000003), rs2=x20 (0x00000005), rd=x8
TOP: ID/EX: imm=0x00000008
TOP: EX/MEM: ALU result=0x00000014 for rd=x21
WBMUX: Selected ALU result: 0xffffffef
ALU INPUT: rs1_data_i = 0x00000003 (bytes: 03 00 00 00)
ALU INPUT: rs2_data_i = 0x00000008 (bytes: 08 00 00 00)
ALU INPUT: alu_op_in = 1011
ALU BNE: 0x00000003 != 0x00000008 = 1
ALU OUTPUT: alu_res_d = 0xfffffffb (bytes: fb ff ff ff)
ALU FLAGS: zero=1, negative=1, overflow=0
IMEM: Reading from address 0x00000090, mem_index=36, instruction=0x00a00b13
ALU OUTPUT: alu_res_d = 0xfffffffb (bytes=fb ff ff ff)
ALU FLAGS: zero=1, negative=1, overflow=0
TOP: Executed instruction 35: 0xfff00b13 at PC=0x0000008c
DECODE: Instruction: 0xfff00b13
DECODE: Opcode: 0x13, funct3: 0x0, funct7: 0x7f
DECODE: rs1: x0, rs2: x31, rd: x22
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x00000014, rd=x21
TOP: IF/ID: Loading instruction 0x00a00b13 from PC 0x00000090
TOP: ID/EX: Processing instruction 0xfff00b13
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x31 (0x00000000), rd=x22
TOP: ID/EX: imm=0xffffffff
TOP: EX/MEM: Branch condition=1
TOP: MEM/WB: Writing back 0x00000014 to rd=x21
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x21, result_src=00
WBMUX: Selected ALU result: 0x00000014
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0xffffffff (bytes: ff ff ff ff)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0xffffffff = 0xffffffff (decimal: 0 + -1 = -1)
ALU ADD RESULT BYTES: ff ff ff ff
ALU OUTPUT: alu_res_d = 0xffffffff (bytes: ff ff ff ff)
ALU FLAGS: zero=0, negative=1, overflow=0
IMEM: Reading from address 0x00000094, mem_index=37, instruction=0x01002b83
PC: Branch from 0x00000088 to 0x00000090 (imm=0x00000008)
ALU OUTPUT: alu_res_d = 0xffffffff (bytes=ff ff ff ff)
ALU FLAGS: zero=0, negative=1, overflow=0
TOP: About to write to register x21, value=0x00000014, reg_write_en=1
TOP: TOP: About to write to register x21, value=0x00000014, reg_write_en=1
TOP: Executed instruction 36: 0x00a00b13 at PC=0x00000090
DECODE: Instruction: 0x00a00b13
DECODE: Opcode: 0x13, funct3: 0x0, funct7: 0x00
DECODE: rs1: x0, rs2: x10, rd: x22
REGFILE: Writing 0x00000014 to x21
TOP: IF/ID: Inserting NOP due to branch/jump
TOP: ID/EX: Inserting NOP due to branch/jump
TOP: EX/MEM: ALU result=0xffffffff for rd=x22
WBMUX: Selected ALU result: 0xfffffffb
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000000 = 0x00000000 (decimal: 0 + 0 = 0)
ALU ADD RESULT BYTES: 00 00 00 00
ALU OUTPUT: alu_res_d = 0x00000000 (bytes: 00 00 00 00)
ALU FLAGS: zero=1, negative=0, overflow=0
IMEM: Reading from address 0x00000090, mem_index=36, instruction=0x00a00b13
ALU OUTPUT: alu_res_d = 0x00000000 (bytes=00 00 00 00)
ALU FLAGS: zero=1, negative=0, overflow=0
TOP: Executed instruction 37: 0x00000013 at PC=0x00000094
DECODE: Instruction: 0x00000013
DECODE: Opcode: 0x13, funct3: 0x0, funct7: 0x00
DECODE: rs1: x0, rs2: x0, rd: x0
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0xffffffff, rd=x22
TOP: IF/ID: Loading instruction 0x00a00b13 from PC 0x00000090
TOP: ID/EX: Processing instruction 0x00000013
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x0 (0x00000000), rd=x0
TOP: ID/EX: imm=0x00000000
TOP: MEM/WB: Writing back 0xffffffff to rd=x22
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x22, result_src=00
WBMUX: Selected ALU result: 0xffffffff
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000000 = 0x00000000 (decimal: 0 + 0 = 0)
ALU ADD RESULT BYTES: 00 00 00 00
ALU OUTPUT: alu_res_d = 0x00000000 (bytes: 00 00 00 00)
ALU FLAGS: zero=1, negative=0, overflow=0
IMEM: Reading from address 0x00000094, mem_index=37, instruction=0x01002b83
TOP: About to write to register x22, value=0xffffffff, reg_write_en=1
TOP: TOP: About to write to register x22, value=0xffffffff, reg_write_en=1
TOP: Executed instruction 38: 0x00a00b13 at PC=0x00000090
DECODE: Instruction: 0x00a00b13
DECODE: Opcode: 0x13, funct3: 0x0, funct7: 0x00
DECODE: rs1: x0, rs2: x10, rd: x22
REGFILE: Writing 0xffffffff to x22
TOP: IF/ID: Loading instruction 0x01002b83 from PC 0x00000094
TOP: ID/EX: Processing instruction 0x00a00b13
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x10 (0x00000000), rd=x22
TOP: ID/EX: imm=0x0000000a
TOP: EX/MEM: ALU result=0x00000000 for rd=x0
WBMUX: Selected ALU result: 0x00000000
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x0000000a (bytes: 0a 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x0000000a = 0x0000000a (decimal: 0 + 10 = 10)
ALU ADD RESULT BYTES: 0a 00 00 00
ALU OUTPUT: alu_res_d = 0x0000000a (bytes: 0a 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x00000098, mem_index=38, instruction=0x015a0c13
ALU OUTPUT: alu_res_d = 0x0000000a (bytes=0a 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
TOP: Executed instruction 39: 0x01002b83 at PC=0x00000094
DECODE: Instruction: 0x01002b83
DECODE: Opcode: 0x03, funct3: 0x2, funct7: 0x00
DECODE: rs1: x0, rs2: x16, rd: x23
TOP: IF/ID: Loading instruction 0x015a0c13 from PC 0x00000098
TOP: ID/EX: Processing instruction 0x01002b83
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x16 (0xaaaab000), rd=x23
TOP: ID/EX: imm=0x00000010
TOP: EX/MEM: ALU result=0x0000000a for rd=x22
TOP: MEM/WB: Writing back 0x00000000 to rd=x0
WBMUX: Selected ALU result: 0x00000000
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000010 (bytes: 10 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000010 = 0x00000010 (decimal: 0 + 16 = 16)
ALU ADD RESULT BYTES: 10 00 00 00
ALU OUTPUT: alu_res_d = 0x00000010 (bytes: 10 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x0000009c, mem_index=39, instruction=0x018c0c93
ALU OUTPUT: alu_res_d = 0x00000010 (bytes=10 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
TOP: Executed instruction 40: 0x015a0c13 at PC=0x00000098
DECODE: Instruction: 0x015a0c13
DECODE: Opcode: 0x13, funct3: 0x0, funct7: 0x00
DECODE: rs1: x20, rs2: x21, rd: x24
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x0000000a, rd=x22
TOP: IF/ID: Loading instruction 0x018c0c93 from PC 0x0000009c
TOP: ID/EX: Processing instruction 0x015a0c13
TOP: ID/EX: rs1=x20 (0x00000005), rs2=x21 (0x00000014), rd=x24
TOP: ID/EX: imm=0x00000015
TOP: EX/MEM: ALU result=0x00000010 for rd=x23
TOP: MEM/WB: Writing back 0x0000000a to rd=x22
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x22, result_src=00
DMEM: LOAD INSTRUCTION DETECTED
DMEM: MEMORY DEBUG: Reading from address 0x00000010
DMEM: INSTRUCTION: 0x01002b83
DMEM: PC: 0x00000094
DMEM: MEMORY READ WORD: addr=0x00000010, data=0x000000fd
DMEM:   Final register value: 0x000000fd
DMEM: MEMORY STATUS: Memory[19:16] = fd 00 00 00
WBMUX: Selected ALU result: 0x0000000a
ALU INPUT: rs1_data_i = 0x00000005 (bytes: 05 00 00 00)
ALU INPUT: rs2_data_i = 0x00000015 (bytes: 15 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000005 + 0x00000015 = 0x0000001a (decimal: 5 + 21 = 26)
ALU ADD RESULT BYTES: 1a 00 00 00
ALU OUTPUT: alu_res_d = 0x0000001a (bytes: 1a 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x000000a0, mem_index=40, instruction=0x019c8d13
ALU OUTPUT: alu_res_d = 0x0000001a (bytes=1a 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
TOP: MEMORY READ OPERATION: addr=0x00000010, size=2
TOP: About to write to register x22, value=0x0000000a, reg_write_en=1
TOP: TOP: About to write to register x22, value=0x0000000a, reg_write_en=1
TOP: 
EXECUTING MEMORY LOAD: addr=0x00000010
TOP: Executed instruction 41: 0x018c0c93 at PC=0x0000009c
DECODE: Instruction: 0x018c0c93
DECODE: Opcode: 0x13, funct3: 0x0, funct7: 0x00
DECODE: rs1: x24, rs2: x24, rd: x25
REGFILE: Writing 0x0000000a to x22
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x00000010, rd=x23
TOP: IF/ID: Loading instruction 0x019c8d13 from PC 0x000000a0
TOP: ID/EX: Processing instruction 0x018c0c93
TOP: ID/EX: rs1=x24 (0x00000000), rs2=x24 (0x00000000), rd=x25
TOP: ID/EX: imm=0x00000018
TOP: EX/MEM: ALU result=0x0000001a for rd=x24
TOP: MEM/WB: Memory read data=0x000000fd from addr=0x00000010
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x23, result_src=01
WBMUX: Selected Memory data: 0x000000fd
FWD: Forwarding rs1 from MEM stage: x24
FWD: Forwarding rs2 from MEM stage: x24
TOP: Using forwarded RS1: forward_a=10, value=0x0000001a
TOP: Using forwarded RS2: forward_b=10, value=0x0000001a
ALU INPUT: rs1_data_i = 0x0000001a (bytes: 1a 00 00 00)
ALU INPUT: rs2_data_i = 0x00000018 (bytes: 18 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x0000001a + 0x00000018 = 0x00000032 (decimal: 26 + 24 = 50)
ALU ADD RESULT BYTES: 32 00 00 00
ALU OUTPUT: alu_res_d = 0x00000032 (bytes: 32 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x000000a4, mem_index=41, instruction=0x01ad0d93
ALU OUTPUT: alu_res_d = 0x00000032 (bytes=32 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
TOP: About to write to register x23, value=0x000000fd, reg_write_en=1
TOP: TOP: About to write to register x23, value=0x000000fd, reg_write_en=1
TOP: Executed instruction 42: 0x019c8d13 at PC=0x000000a0
DECODE: Instruction: 0x019c8d13
DECODE: Opcode: 0x13, funct3: 0x0, funct7: 0x00
DECODE: rs1: x25, rs2: x25, rd: x26
REGFILE: Writing 0x000000fd to x23
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x0000001a, rd=x24
TOP: IF/ID: Loading instruction 0x01ad0d93 from PC 0x000000a4
TOP: ID/EX: Processing instruction 0x019c8d13
TOP: ID/EX: rs1=x25 (0x00000000), rs2=x25 (0x00000000), rd=x26
TOP: ID/EX: imm=0x00000019
TOP: EX/MEM: ALU result=0x00000032 for rd=x25
TOP: MEM/WB: Writing back 0x0000001a to rd=x24
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x24, result_src=00
WBMUX: Selected ALU result: 0x0000001a
FWD: Forwarding rs1 from MEM stage: x25
FWD: Forwarding rs2 from MEM stage: x25
TOP: Using forwarded RS1: forward_a=10, value=0x00000032
TOP: Using forwarded RS2: forward_b=10, value=0x00000032
ALU INPUT: rs1_data_i = 0x00000032 (bytes: 32 00 00 00)
ALU INPUT: rs2_data_i = 0x00000019 (bytes: 19 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000032 + 0x00000019 = 0x0000004b (decimal: 50 + 25 = 75)
ALU ADD RESULT BYTES: 4b 00 00 00
ALU OUTPUT: alu_res_d = 0x0000004b (bytes: 4b 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x000000a8, mem_index=42, instruction=0x01b02e23
ALU OUTPUT: alu_res_d = 0x0000004b (bytes=4b 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
TOP: About to write to register x24, value=0x0000001a, reg_write_en=1
TOP: TOP: About to write to register x24, value=0x0000001a, reg_write_en=1
TOP: Executed instruction 43: 0x01ad0d93 at PC=0x000000a4
DECODE: Instruction: 0x01ad0d93
DECODE: Opcode: 0x13, funct3: 0x0, funct7: 0x00
DECODE: rs1: x26, rs2: x26, rd: x27
REGFILE: Writing 0x0000001a to x24
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x00000032, rd=x25
TOP: IF/ID: Loading instruction 0x01b02e23 from PC 0x000000a8
TOP: ID/EX: Processing instruction 0x01ad0d93
TOP: ID/EX: rs1=x26 (0x00000000), rs2=x26 (0x00000000), rd=x27
TOP: ID/EX: imm=0x0000001a
TOP: EX/MEM: ALU result=0x0000004b for rd=x26
TOP: MEM/WB: Writing back 0x00000032 to rd=x25
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x25, result_src=00
WBMUX: Selected ALU result: 0x00000032
FWD: Forwarding rs1 from MEM stage: x26
FWD: Forwarding rs2 from MEM stage: x26
TOP: Using forwarded RS1: forward_a=10, value=0x0000004b
TOP: Using forwarded RS2: forward_b=10, value=0x0000004b
ALU INPUT: rs1_data_i = 0x0000004b (bytes: 4b 00 00 00)
ALU INPUT: rs2_data_i = 0x0000001a (bytes: 1a 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x0000004b + 0x0000001a = 0x00000065 (decimal: 75 + 26 = 101)
ALU ADD RESULT BYTES: 65 00 00 00
ALU OUTPUT: alu_res_d = 0x00000065 (bytes: 65 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x000000ac, mem_index=43, instruction=0x01c02e83
ALU OUTPUT: alu_res_d = 0x00000065 (bytes=65 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
TOP: About to write to register x25, value=0x00000032, reg_write_en=1
TOP: TOP: About to write to register x25, value=0x00000032, reg_write_en=1
TOP: Executed instruction 44: 0x01b02e23 at PC=0x000000a8
DECODE: Instruction: 0x01b02e23
DECODE: Opcode: 0x23, funct3: 0x2, funct7: 0x00
DECODE: rs1: x0, rs2: x27, rd: x28
REGFILE: Writing 0x00000032 to x25
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x0000004b, rd=x26
TOP: IF/ID: Loading instruction 0x01c02e83 from PC 0x000000ac
TOP: ID/EX: Processing instruction 0x01b02e23
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x27 (0x00000000), rd=x28
TOP: ID/EX: imm=0x0000001c
TOP: EX/MEM: ALU result=0x00000065 for rd=x27
TOP: MEM/WB: Writing back 0x0000004b to rd=x26
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x26, result_src=00
WBMUX: Selected ALU result: 0x0000004b
FWD: Forwarding rs2 from MEM stage: x27
TOP: Using forwarded RS2: forward_b=10, value=0x00000065
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x0000001c (bytes: 1c 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x0000001c = 0x0000001c (decimal: 0 + 28 = 28)
ALU ADD RESULT BYTES: 1c 00 00 00
ALU OUTPUT: alu_res_d = 0x0000001c (bytes: 1c 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x000000b0, mem_index=44, instruction=0x01d00e13
ALU OUTPUT: alu_res_d = 0x0000001c (bytes=1c 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
TOP: STORE INSTRUCTION IN EX STAGE: instr=0x01b02e23, rs2_addr=x27, rs2_data=0x00000000
TOP: STORE FORWARDING ACTIVE: forward_b=10
TOP: About to write to register x26, value=0x0000004b, reg_write_en=1
TOP: TOP: About to write to register x26, value=0x0000004b, reg_write_en=1
TOP: Executed instruction 45: 0x01c02e83 at PC=0x000000ac
DECODE: Instruction: 0x01c02e83
DECODE: Opcode: 0x03, funct3: 0x2, funct7: 0x00
DECODE: rs1: x0, rs2: x28, rd: x29
REGFILE: Writing 0x0000004b to x26
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x00000065, rd=x27
TOP: IF/ID: Loading instruction 0x01d00e13 from PC 0x000000b0
TOP: ID/EX: Processing instruction 0x01c02e83
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x28 (0x00000000), rd=x29
TOP: ID/EX: imm=0x0000001c
TOP: STORE INSTRUCTION MOVING TO MEM STAGE:
TOP:   rs2_addr=x27, forwarded=1, forward_sel=10
TOP:   Original rs2_data=0x00000000
TOP:   Forwarded rs2_data from MEM=0x00000065
TOP: MEM/WB: Writing back 0x00000065 to rd=x27
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x27, result_src=00
WBMUX: Selected ALU result: 0x00000065
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x0000001c (bytes: 1c 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x0000001c = 0x0000001c (decimal: 0 + 28 = 28)
ALU ADD RESULT BYTES: 1c 00 00 00
ALU OUTPUT: alu_res_d = 0x0000001c (bytes: 1c 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x000000b4, mem_index=45, instruction=0x01c02f23
TOP: MEMORY STORE EXECUTION: addr=0x0000001c, data=0x00000065
TOP: MEMORY WRITE OPERATION: addr=0x0000001c, data=0x00000065, size=2
TOP: About to write to register x27, value=0x00000065, reg_write_en=1
TOP: TOP: About to write to register x27, value=0x00000065, reg_write_en=1
TOP: MEMORY WRITE EXECUTING: addr=0x0000001c, data=0x00000065
TOP: 
EXECUTING MEMORY STORE: addr=0x0000001c, data=0x00000065
TOP:   STORE INSTRUCTION: Using rs2=x27 (value=0x00000065)
TOP: Executed instruction 46: 0x01d00e13 at PC=0x000000b0
DECODE: Instruction: 0x01d00e13
DECODE: Opcode: 0x13, funct3: 0x0, funct7: 0x00
DECODE: rs1: x0, rs2: x29, rd: x28
DMEM: SAVE INSTRUCTION DETECTED
DMEM: INSTRUCTION: 0x01b02e23
DMEM: MEMORY DEBUG: Writing to address 0x0000001c, data=0x00000065, size=2
DMEM: MEMORY WRITE WORD: addr=0x0000001c, data=0x00000065
DMEM:   Writing bytes: 65 00 00 00
DMEM: ** MEMORY STORE: WORD 0x00000065 written to address 0x0000001c **
DMEM: MEMORY POST-WRITE CHECK: Address 0x0000001c now contains bytes: 00 00 00 00
REGFILE: Writing 0x00000065 to x27
TOP: IF/ID: Loading instruction 0x01c02f23 from PC 0x000000b4
TOP: ID/EX: Processing instruction 0x01d00e13
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x29 (0x00000000), rd=x28
TOP: ID/EX: imm=0x0000001d
TOP: EX/MEM: ALU result=0x0000001c for rd=x29
DMEM: LOAD INSTRUCTION DETECTED
DMEM: MEMORY DEBUG: Reading from address 0x0000001c
DMEM: INSTRUCTION: 0x01c02e83
DMEM: PC: 0x000000ac
DMEM: MEMORY READ WORD: addr=0x0000001c, data=0x00000065
DMEM:   Final register value: 0x00000065
DMEM: MEMORY STATUS: Memory[31:28] = 65 00 00 00
WBMUX: Selected ALU result: 0x0000001c
FWD: Forwarding rs2 from MEM stage: x29
TOP: Using forwarded RS2: forward_b=10, value=0x0000001c
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x0000001d (bytes: 1d 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x0000001d = 0x0000001d (decimal: 0 + 29 = 29)
ALU ADD RESULT BYTES: 1d 00 00 00
ALU OUTPUT: alu_res_d = 0x0000001d (bytes: 1d 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x000000b8, mem_index=46, instruction=0x01c00f13
ALU OUTPUT: alu_res_d = 0x0000001d (bytes=1d 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
TOP: MEMORY READ OPERATION: addr=0x0000001c, size=2
TOP: 
EXECUTING MEMORY LOAD: addr=0x0000001c
TOP: Executed instruction 47: 0x01c02f23 at PC=0x000000b4
DECODE: Instruction: 0x01c02f23
DECODE: Opcode: 0x23, funct3: 0x2, funct7: 0x00
DECODE: rs1: x0, rs2: x28, rd: x30
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x0000001c, rd=x29
TOP: IF/ID: Loading instruction 0x01c00f13 from PC 0x000000b8
TOP: ID/EX: Processing instruction 0x01c02f23
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x28 (0x00000000), rd=x30
TOP: ID/EX: imm=0x0000001e
TOP: EX/MEM: ALU result=0x0000001d for rd=x28
TOP: MEM/WB: Memory read data=0x00000065 from addr=0x0000001c
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x29, result_src=01
WBMUX: Selected Memory data: 0x00000065
FWD: Forwarding rs2 from MEM stage: x28
TOP: Using forwarded RS2: forward_b=10, value=0x0000001d
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x0000001e (bytes: 1e 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x0000001e = 0x0000001e (decimal: 0 + 30 = 30)
ALU ADD RESULT BYTES: 1e 00 00 00
ALU OUTPUT: alu_res_d = 0x0000001e (bytes: 1e 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x000000bc, mem_index=47, instruction=0x01e00f93
ALU OUTPUT: alu_res_d = 0x0000001e (bytes=1e 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
DMEM: MEMORY CONTENTS after write at addr=0x0000001c:
DMEM:   Memory[31:28] = 65 00 00 00
DMEM:   Reconstructed word: 0x00000065
TOP: STORE INSTRUCTION IN EX STAGE: instr=0x01c02f23, rs2_addr=x28, rs2_data=0x00000000
TOP: STORE FORWARDING ACTIVE: forward_b=10
TOP: About to write to register x29, value=0x00000065, reg_write_en=1
TOP: TOP: About to write to register x29, value=0x00000065, reg_write_en=1
TOP: Executed instruction 48: 0x01c00f13 at PC=0x000000b8
DECODE: Instruction: 0x01c00f13
DECODE: Opcode: 0x13, funct3: 0x0, funct7: 0x00
DECODE: rs1: x0, rs2: x28, rd: x30
REGFILE: Writing 0x00000065 to x29
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x0000001d, rd=x28
TOP: IF/ID: Loading instruction 0x01e00f93 from PC 0x000000bc
TOP: ID/EX: Processing instruction 0x01c00f13
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x28 (0x00000000), rd=x30
TOP: ID/EX: imm=0x0000001c
TOP: STORE INSTRUCTION MOVING TO MEM STAGE:
TOP:   rs2_addr=x28, forwarded=1, forward_sel=10
TOP:   Original rs2_data=0x00000000
TOP:   Forwarded rs2_data from MEM=0x0000001d
TOP: MEM/WB: Writing back 0x0000001d to rd=x28
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x28, result_src=00
WBMUX: Selected ALU result: 0x0000001d
FWD: Forwarding rs2 from WB stage: x28
TOP: Using forwarded RS2: forward_b=01, value=0x0000001d
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x0000001c (bytes: 1c 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x0000001c = 0x0000001c (decimal: 0 + 28 = 28)
ALU ADD RESULT BYTES: 1c 00 00 00
ALU OUTPUT: alu_res_d = 0x0000001c (bytes: 1c 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x000000c0, mem_index=48, instruction=0x01ef0f33
ALU OUTPUT: alu_res_d = 0x0000001c (bytes=1c 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
TOP: MEMORY STORE EXECUTION: addr=0x0000001e, data=0x0000001d
TOP: MEMORY WRITE OPERATION: addr=0x0000001e, data=0x0000001d, size=2
TOP: About to write to register x28, value=0x0000001d, reg_write_en=1
TOP: TOP: About to write to register x28, value=0x0000001d, reg_write_en=1
TOP: MEMORY WRITE EXECUTING: addr=0x0000001e, data=0x0000001d
TOP: 
EXECUTING MEMORY STORE: addr=0x0000001e, data=0x0000001d
TOP:   STORE INSTRUCTION: Using rs2=x28 (value=0x0000001d)
TOP: Executed instruction 49: 0x01e00f93 at PC=0x000000bc
DECODE: Instruction: 0x01e00f93
DECODE: Opcode: 0x13, funct3: 0x0, funct7: 0x00
DECODE: rs1: x0, rs2: x30, rd: x31
DMEM: SAVE INSTRUCTION DETECTED
DMEM: INSTRUCTION: 0x01c02f23
DMEM: MEMORY DEBUG: Writing to address 0x0000001e, data=0x0000001d, size=2
DMEM: MEMORY WRITE WORD: addr=0x0000001e, data=0x0000001d
DMEM:   Writing bytes: 1d 00 00 00
DMEM: ** MEMORY STORE: WORD 0x0000001d written to address 0x0000001e **
DMEM: MEMORY POST-WRITE CHECK: Address 0x0000001e now contains bytes: 00 00 00 00
REGFILE: Writing 0x0000001d to x28
TOP: IF/ID: Loading instruction 0x01ef0f33 from PC 0x000000c0
TOP: ID/EX: Processing instruction 0x01e00f93
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x30 (0x00000000), rd=x31
TOP: ID/EX: imm=0x0000001e
TOP: EX/MEM: ALU result=0x0000001c for rd=x30
WBMUX: Selected ALU result: 0x0000001e
FWD: Forwarding rs2 from MEM stage: x30
TOP: Using forwarded RS2: forward_b=10, value=0x0000001c
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x0000001e (bytes: 1e 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x0000001e = 0x0000001e (decimal: 0 + 30 = 30)
ALU ADD RESULT BYTES: 1e 00 00 00
ALU OUTPUT: alu_res_d = 0x0000001e (bytes: 1e 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x000000c4, mem_index=49, instruction=0x018000ef
ALU OUTPUT: alu_res_d = 0x0000001e (bytes=1e 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
TOP: Executed instruction 50: 0x01ef0f33 at PC=0x000000c0
DECODE: Instruction: 0x01ef0f33
DECODE: Opcode: 0x33, funct3: 0x0, funct7: 0x00
DECODE: rs1: x30, rs2: x30, rd: x30
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x0000001c, rd=x30
TOP: IF/ID: Loading instruction 0x018000ef from PC 0x000000c4
TOP: ID/EX: Processing instruction 0x01ef0f33
TOP: ID/EX: rs1=x30 (0x00000000), rs2=x30 (0x00000000), rd=x30
TOP: EX/MEM: ALU result=0x0000001e for rd=x31
TOP: MEM/WB: Writing back 0x0000001c to rd=x30
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x30, result_src=00
WBMUX: Selected ALU result: 0x0000001c
FWD: Forwarding rs1 from WB stage: x30
FWD: Forwarding rs2 from WB stage: x30
TOP: Using forwarded RS1: forward_a=01, value=0x0000001c
TOP: Using forwarded RS2: forward_b=01, value=0x0000001c
DECODE: JAL instruction detected, rd=x1, imm=0x00000018
ALU INPUT: rs1_data_i = 0x0000001c (bytes: 1c 00 00 00)
ALU INPUT: rs2_data_i = 0x0000001c (bytes: 1c 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x0000001c + 0x0000001c = 0x00000038 (decimal: 28 + 28 = 56)
ALU ADD RESULT BYTES: 38 00 00 00
ALU OUTPUT: alu_res_d = 0x00000038 (bytes: 38 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x000000c8, mem_index=50, instruction=0x00000013
ALU OUTPUT: alu_res_d = 0x00000038 (bytes=38 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
DMEM: MEMORY CONTENTS after write at addr=0x0000001e:
DMEM:   Memory[33:30] = 1d 00 00 00
DMEM:   Reconstructed word: 0x0000001d
TOP: JUMP TRACKING: JAL detected at PC=0x000000c4, instr=0x018000ef
TOP: JUMP TRACKING: Target should be PC=0x000000dc
TOP: About to write to register x30, value=0x0000001c, reg_write_en=1
TOP: TOP: About to write to register x30, value=0x0000001c, reg_write_en=1
TOP: Executed instruction 51: 0x018000ef at PC=0x000000c4
DECODE: Instruction: 0x018000ef
DECODE: Opcode: 0x6f, funct3: 0x0, funct7: 0x00
DECODE: rs1: x0, rs2: x24, rd: x1
REGFILE: Writing 0x0000001c to x30
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x0000001e, rd=x31
TOP: IF/ID: Loading instruction 0x00000013 from PC 0x000000c8
TOP: ID/EX: Processing instruction 0x018000ef
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x24 (0x0000001a), rd=x1
TOP: ID/EX: imm=0x00000018
TOP: EX/MEM: ALU result=0x00000038 for rd=x30
TOP: MEM/WB: Writing back 0x0000001e to rd=x31
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x31, result_src=00
WBMUX: Selected ALU result: 0x0000001e
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000018 (bytes: 18 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000018 = 0x00000018 (decimal: 0 + 24 = 24)
ALU ADD RESULT BYTES: 18 00 00 00
ALU OUTPUT: alu_res_d = 0x00000018 (bytes: 18 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x000000cc, mem_index=51, instruction=0x00000013
ALU OUTPUT: alu_res_d = 0x00000018 (bytes=18 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
TOP: About to write to register x31, value=0x0000001e, reg_write_en=1
TOP: TOP: About to write to register x31, value=0x0000001e, reg_write_en=1
TOP: Executed instruction 52: 0x00000013 at PC=0x000000c8
DECODE: Instruction: 0x00000013
DECODE: Opcode: 0x13, funct3: 0x0, funct7: 0x00
DECODE: rs1: x0, rs2: x0, rd: x0
REGFILE: Writing 0x0000001e to x31
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x00000038, rd=x30
TOP: IF/ID: Loading instruction 0x00000013 from PC 0x000000cc
TOP: ID/EX: Processing instruction 0x00000013
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x0 (0x00000000), rd=x0
TOP: ID/EX: imm=0x00000000
TOP: EX/MEM: ALU result=0x00000018 for rd=x1
TOP: MEM/WB: Writing back 0x00000038 to rd=x30
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x30, result_src=00
WBMUX: Selected ALU result: 0x00000038
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000000 = 0x00000000 (decimal: 0 + 0 = 0)
ALU ADD RESULT BYTES: 00 00 00 00
ALU OUTPUT: alu_res_d = 0x00000000 (bytes: 00 00 00 00)
ALU FLAGS: zero=1, negative=0, overflow=0
IMEM: Reading from address 0x000000d0, mem_index=52, instruction=0x00000013
PC: JAL from 0x000000c4 to 0x000000dc (imm=0x00000018)
ALU OUTPUT: alu_res_d = 0x00000000 (bytes=00 00 00 00)
ALU FLAGS: zero=1, negative=0, overflow=0
TOP: JUMP TRACKING: Jump executing in MEM stage, PC=0x000000c4, target=0x000000dc
TOP: About to write to register x30, value=0x00000038, reg_write_en=1
TOP: TOP: About to write to register x30, value=0x00000038, reg_write_en=1
TOP: Executed instruction 53: 0x00000013 at PC=0x000000cc
DECODE: Instruction: 0x00000013
DECODE: Opcode: 0x13, funct3: 0x0, funct7: 0x00
DECODE: rs1: x0, rs2: x0, rd: x0
REGFILE: Writing 0x00000038 to x30
TOP: PIPELINE: MEM/WB stage update - ex_mem_alu_result=0x00000018, rd=x1
TOP: IF/ID: Inserting NOP due to branch/jump
TOP: ID/EX: Inserting NOP due to branch/jump
TOP: EX/MEM: ALU result=0x00000000 for rd=x0
TOP: MEM/WB: Writing back 0x00000018 to rd=x1
TOP: PIPELINE: MEM/WB update - Setting mem_wb_reg_write=1, mem_wb_rd_addr=x1, result_src=10
WBMUX: Selected PC+4: 0x000000c8
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000000 = 0x00000000 (decimal: 0 + 0 = 0)
ALU ADD RESULT BYTES: 00 00 00 00
ALU OUTPUT: alu_res_d = 0x00000000 (bytes: 00 00 00 00)
ALU FLAGS: zero=1, negative=0, overflow=0
IMEM: Reading from address 0x000000dc, mem_index=55, instruction=0x00008067
TOP: About to write to register x1, value=0x000000c8, reg_write_en=1
TOP: TOP: About to write to register x1, value=0x000000c8, reg_write_en=1
TOP: Executed instruction 54: 0x00000013 at PC=0x000000d0
DECODE: Instruction: 0x00000013
DECODE: Opcode: 0x13, funct3: 0x0, funct7: 0x00
DECODE: rs1: x0, rs2: x0, rd: x0
REGFILE: Writing 0x000000c8 to x1
TOP: IF/ID: Loading instruction 0x00008067 from PC 0x000000dc
TOP: ID/EX: Processing instruction 0x00000013
TOP: ID/EX: rs1=x0 (0x00000000), rs2=x0 (0x00000000), rd=x0
TOP: ID/EX: imm=0x00000000
TOP: MEM/WB: Writing back 0x00000000 to rd=x0
WBMUX: Selected ALU result: 0x00000000
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x00000000 = 0x00000000 (decimal: 0 + 0 = 0)
ALU ADD RESULT BYTES: 00 00 00 00
ALU OUTPUT: alu_res_d = 0x00000000 (bytes: 00 00 00 00)
ALU FLAGS: zero=1, negative=0, overflow=0
IMEM: Reading from address 0x000000e0, mem_index=56, instruction=0x12345837
TOP: Executed instruction 55: 0x00008067 at PC=0x000000dc
DECODE: Instruction: 0x00008067
DECODE: Opcode: 0x67, funct3: 0x0, funct7: 0x00
DECODE: rs1: x1, rs2: x0, rd: x0
TOP: IF/ID: Loading instruction 0x12345837 from PC 0x000000e0
TOP: ID/EX: Processing instruction 0x00008067
TOP: ID/EX: rs1=x1 (0x000000c8), rs2=x0 (0x00000000), rd=x0
TOP: ID/EX: imm=0x00000000
TOP: EX/MEM: ALU result=0x00000000 for rd=x0
WBMUX: Selected ALU result: 0x00000000
ALU INPUT: rs1_data_i = 0x000000c8 (bytes: c8 00 00 00)
ALU INPUT: rs2_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x000000c8 + 0x00000000 = 0x000000c8 (decimal: 200 + 0 = 200)
ALU ADD RESULT BYTES: c8 00 00 00
ALU OUTPUT: alu_res_d = 0x000000c8 (bytes: c8 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x000000e4, mem_index=57, instruction=0x00100073
ALU OUTPUT: alu_res_d = 0x000000c8 (bytes=c8 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
TOP: Executed instruction 56: 0x12345837 at PC=0x000000e0
DECODE: Instruction: 0x12345837
DECODE: Opcode: 0x37, funct3: 0x5, funct7: 0x09
DECODE: rs1: x8, rs2: x3, rd: x16
TOP: IF/ID: Loading instruction 0x00100073 from PC 0x000000e4
TOP: ID/EX: Processing instruction 0x12345837
TOP: ID/EX: rs1=x8 (0x00000002), rs2=x3 (0x00000003), rd=x16
TOP: ID/EX: imm=0x12345000
TOP: EX/MEM: ALU result=0x000000c8 for rd=x0
TOP: MEM/WB: Writing back 0x00000000 to rd=x0
WBMUX: Selected ALU result: 0x00000000
ALU INPUT: rs1_data_i = 0x00000002 (bytes: 02 00 00 00)
ALU INPUT: rs2_data_i = 0x12345000 (bytes: 00 50 34 12)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000002 + 0x12345000 = 0x12345002 (decimal: 2 + 305418240 = 305418242)
ALU ADD RESULT BYTES: 02 50 34 12
ALU OUTPUT: alu_res_d = 0x12345002 (bytes: 02 50 34 12)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x000000e8, mem_index=58, instruction=0x00000000
PC: JALR from 0x000000dc to 0x00000002 (rs1_data=0x00000002, imm=0x00000000)
WARNING: PC invalid (0x00000002). Program continuing but PC limited.
ALU OUTPUT: alu_res_d = 0x12345002 (bytes=02 50 34 12)
ALU FLAGS: zero=0, negative=0, overflow=0
TOP: JUMP TRACKING: Jump executing in MEM stage, PC=0x000000dc, target=0x000000dc
TOP: 
==== EBREAK DETECTED at IF/ID stage (PC=0x000000e4) ====
TOP: Register dump created: register_dump.txt
REGFILE: ========== Register File Dump (Cycle 60) ==========
  x0 (zero ): 0x00000000 (bytes: 00 00 00 00)
  x1 (ra   ): 0x000000c8 (bytes: c8 00 00 00)
  x2 (sp   ): 0x00000002 (bytes: 02 00 00 00)
  x3 (gp   ): 0x00000003 (bytes: 03 00 00 00)
  x4 (tp   ): 0xfffffffe (bytes: fe ff ff ff)
  x5 (t0   ): 0x00000000 (bytes: 00 00 00 00)
  x6 (t1   ): 0x00000003 (bytes: 03 00 00 00)
  x7 (t2   ): 0x00000003 (bytes: 03 00 00 00)
  x8 (s0/fp): 0x00000002 (bytes: 02 00 00 00)
  x9 (s1   ): 0x00000000 (bytes: 00 00 00 00)
  x10 (a0   ): 0x00000000 (bytes: 00 00 00 00)
  x11 (a1   ): 0x0000000b (bytes: 0b 00 00 00)
  x12 (a2   ): 0x00000009 (bytes: 09 00 00 00)
  x13 (a3   ): 0x0000000b (bytes: 0b 00 00 00)
  x14 (a4   ): 0x000000fd (bytes: fd 00 00 00)
  x15 (a5   ): 0xfffffffd (bytes: fd ff ff ff)
  x16 (a6   ): 0xaaaab000 (bytes: 00 b0 aa aa)
  x17 (a7   ): 0xffffb000 (bytes: 00 b0 ff ff)
  x18 (s2   ): 0xffffb000 (bytes: 00 b0 ff ff)
  x19 (s3   ): 0x00000003 (bytes: 03 00 00 00)
  x20 (s4   ): 0x00000005 (bytes: 05 00 00 00)
  x21 (s5   ): 0x00000014 (bytes: 14 00 00 00)
  x22 (s6   ): 0x0000000a (bytes: 0a 00 00 00)
  x23 (s7   ): 0x000000fd (bytes: fd 00 00 00)
  x24 (s8   ): 0x0000001a (bytes: 1a 00 00 00)
  x25 (s9   ): 0x00000032 (bytes: 32 00 00 00)
  x26 (s10  ): 0x0000004b (bytes: 4b 00 00 00)
  x27 (s11  ): 0x00000065 (bytes: 65 00 00 00)
  x28 (t3   ): 0x0000001d (bytes: 1d 00 00 00)
  x29 (t4   ): 0x00000065 (bytes: 65 00 00 00)
  x30 (t5   ): 0x00000038 (bytes: 38 00 00 00)
  x31 (t6   ): 0x0000001e (bytes: 1e 00 00 00)
==================================================
- ../core/../core/top.sv:784: Verilog $finish
TOP: Executed instruction 57: 0x00100073 at PC=0x000000e4
DECODE: Instruction: 0x00100073
DECODE: Opcode: 0x73, funct3: 0x0, funct7: 0x00
DECODE: rs1: x0, rs2: x1, rd: x0
TOP: IF/ID: Inserting NOP due to branch/jump
TOP: ID/EX: Inserting NOP due to branch/jump
TOP: EX/MEM: ALU result=0x12345002 for rd=x16
TOP: MEM/WB: Writing back 0x000000c8 to rd=x0
WBMUX: Selected PC+4: 0x000000e0
ALU INPUT: rs1_data_i = 0x00000000 (bytes: 00 00 00 00)
ALU INPUT: rs2_data_i = 0x000000c8 (bytes: c8 00 00 00)
ALU INPUT: alu_op_in = 0000
ALU ADD: 0x00000000 + 0x000000c8 = 0x000000c8 (decimal: 0 + 200 = 200)
ALU ADD RESULT BYTES: c8 00 00 00
ALU OUTPUT: alu_res_d = 0x000000c8 (bytes: c8 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0
IMEM: Reading from address 0x000000e8, mem_index=58, instruction=0x00000000
ALU OUTPUT: alu_res_d = 0x000000c8 (bytes=c8 00 00 00)
ALU FLAGS: zero=0, negative=0, overflow=0

=== Final Register Values (RISC-V Little-Endian) ===
x0 ( zero): 0x00000000 (0)
   Bytes (little-endian): 00 00 00 00
x1 (   ra): 0x000000c8 (200)
   Bytes (little-endian): c8 00 00 00
x2 (   sp): 0x00000002 (2)
   Bytes (little-endian): 02 00 00 00
x3 (   gp): 0x00000003 (3)
   Bytes (little-endian): 03 00 00 00
x4 (   tp): 0xfffffffe (-2)
   Bytes (little-endian): fe ff ff ff
x5 (   t0): 0x00000000 (0)
   Bytes (little-endian): 00 00 00 00
x6 (   t1): 0x00000003 (3)
   Bytes (little-endian): 03 00 00 00
x7 (   t2): 0x00000003 (3)
   Bytes (little-endian): 03 00 00 00
x8 (s0/fp): 0x00000002 (2)
   Bytes (little-endian): 02 00 00 00
x9 (   s1): 0x00000000 (0)
   Bytes (little-endian): 00 00 00 00
x10 (   a0): 0x00000000 (0)
   Bytes (little-endian): 00 00 00 00
x11 (   a1): 0x0000000b (11)
   Bytes (little-endian): 0b 00 00 00
x12 (   a2): 0x00000009 (9)
   Bytes (little-endian): 09 00 00 00
x13 (   a3): 0x0000000b (11)
   Bytes (little-endian): 0b 00 00 00
x14 (   a4): 0x000000fd (253)
   Bytes (little-endian): fd 00 00 00
x15 (   a5): 0xfffffffd (-3)
   Bytes (little-endian): fd ff ff ff
x16 (   a6): 0xaaaab000 (-1431654400)
   Bytes (little-endian): 00 b0 aa aa
x17 (   a7): 0xffffb000 (-20480)
   Bytes (little-endian): 00 b0 ff ff
x18 (   s2): 0xffffb000 (-20480)
   Bytes (little-endian): 00 b0 ff ff
x19 (   s3): 0x00000003 (3)
   Bytes (little-endian): 03 00 00 00
x20 (   s4): 0x00000005 (5)
   Bytes (little-endian): 05 00 00 00
x21 (   s5): 0x00000014 (20)
   Bytes (little-endian): 14 00 00 00
x22 (   s6): 0x0000000a (10)
   Bytes (little-endian): 0a 00 00 00
x23 (   s7): 0x000000fd (253)
   Bytes (little-endian): fd 00 00 00
x24 (   s8): 0x0000001a (26)
   Bytes (little-endian): 1a 00 00 00
x25 (   s9): 0x00000032 (50)
   Bytes (little-endian): 32 00 00 00
x26 (  s10): 0x0000004b (75)
   Bytes (little-endian): 4b 00 00 00
x27 (  s11): 0x00000065 (101)
   Bytes (little-endian): 65 00 00 00
x28 (   t3): 0x0000001d (29)
   Bytes (little-endian): 1d 00 00 00
x29 (   t4): 0x00000065 (101)
   Bytes (little-endian): 65 00 00 00
x30 (   t5): 0x00000038 (56)
   Bytes (little-endian): 38 00 00 00
x31 (   t6): 0x0000001e (30)
   Bytes (little-endian): 1e 00 00 00

=== Summary of Executed Instructions ===
Simulation completed at time: 131
Total cycles executed: 0

=== Register Values Summary (RISC-V Little-Endian) ===
x0 ( zero): 0x00000000 (decimal: 0)
   Bytes (little-endian): 00 00 00 00
x1 (   ra): 0x000000c8 (decimal: 200)
   Bytes (little-endian): c8 00 00 00
x2 (   sp): 0x00000002 (decimal: 2)
   Bytes (little-endian): 02 00 00 00
x3 (   gp): 0x00000003 (decimal: 3)
   Bytes (little-endian): 03 00 00 00
x4 (   tp): 0xfffffffe (decimal: -2)
   Bytes (little-endian): fe ff ff ff
x5 (   t0): 0x00000000 (decimal: 0)
   Bytes (little-endian): 00 00 00 00
x6 (   t1): 0x00000003 (decimal: 3)
   Bytes (little-endian): 03 00 00 00
x7 (   t2): 0x00000003 (decimal: 3)
   Bytes (little-endian): 03 00 00 00
x8 (s0/fp): 0x00000002 (decimal: 2)
   Bytes (little-endian): 02 00 00 00
x9 (   s1): 0x00000000 (decimal: 0)
   Bytes (little-endian): 00 00 00 00
x10 (   a0): 0x00000000 (decimal: 0)
   Bytes (little-endian): 00 00 00 00
x11 (   a1): 0x0000000b (decimal: 11)
   Bytes (little-endian): 0b 00 00 00
x12 (   a2): 0x00000009 (decimal: 9)
   Bytes (little-endian): 09 00 00 00
x13 (   a3): 0x0000000b (decimal: 11)
   Bytes (little-endian): 0b 00 00 00
x14 (   a4): 0x000000fd (decimal: 253)
   Bytes (little-endian): fd 00 00 00
x15 (   a5): 0xfffffffd (decimal: -3)
   Bytes (little-endian): fd ff ff ff
x16 (   a6): 0xaaaab000 (decimal: -1431654400)
   Bytes (little-endian): 00 b0 aa aa
x17 (   a7): 0xffffb000 (decimal: -20480)
   Bytes (little-endian): 00 b0 ff ff
x18 (   s2): 0xffffb000 (decimal: -20480)
   Bytes (little-endian): 00 b0 ff ff
x19 (   s3): 0x00000003 (decimal: 3)
   Bytes (little-endian): 03 00 00 00
x20 (   s4): 0x00000005 (decimal: 5)
   Bytes (little-endian): 05 00 00 00
x21 (   s5): 0x00000014 (decimal: 20)
   Bytes (little-endian): 14 00 00 00
x22 (   s6): 0x0000000a (decimal: 10)
   Bytes (little-endian): 0a 00 00 00
x23 (   s7): 0x000000fd (decimal: 253)
   Bytes (little-endian): fd 00 00 00
x24 (   s8): 0x0000001a (decimal: 26)
   Bytes (little-endian): 1a 00 00 00
x25 (   s9): 0x00000032 (decimal: 50)
   Bytes (little-endian): 32 00 00 00
x26 (  s10): 0x0000004b (decimal: 75)
   Bytes (little-endian): 4b 00 00 00
x27 (  s11): 0x00000065 (decimal: 101)
   Bytes (little-endian): 65 00 00 00
x28 (   t3): 0x0000001d (decimal: 29)
   Bytes (little-endian): 1d 00 00 00
x29 (   t4): 0x00000065 (decimal: 101)
   Bytes (little-endian): 65 00 00 00
x30 (   t5): 0x00000038 (decimal: 56)
   Bytes (little-endian): 38 00 00 00
x31 (   t6): 0x0000001e (decimal: 30)
   Bytes (little-endian): 1e 00 00 00
Simulation completed. Register dump generated.
Debug information has been saved to simulation_output.log
